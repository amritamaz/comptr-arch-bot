
 2-bit scheme
 256-bit-wide operations
 3D torus network
 80x86 see Intel 80x86 processors A ABC Atanasoff Berry Computer
 ABI see Application binary interface ABI Absolute addressing mode Intel 80x86
 ACID see Atomicity-consistency- isolation-durability ACID Acknowledgment packets
 ACM see Association of Computing Machinery ACM ACS project
 ALAT see Advanced load address table ALAT Alewife machine
 ALGOL
 ALU
 ALU operands
 ALUs
 ALUs see Arithmetic-logical units ALUs AMAT see Average Memory Access Time AMAT Amazon cloud computing
 AMD
 AMD Athlon
 AMD Barcelona microprocessor Google WSC server
 AMD Fusion
 AMD Opteron address translation
 AMD Opteron data cache
 AMD Opteron example
 AMD processors architecture flaws vs success
 AMD64 paged virtual memory
 AMPS see Advanced mobile phone service AMPS Andreessen Marc
 ARM AMBA OCNs
 ARM Advanced RISC Machine addressing modes
 ARM Cortex-A8
 ARM Cortex-A8 dynamic scheduling
 ARM Cortex-A8 example
 ARM Cortex-A8 memory
 ARM Cortex-A8 vs A9
 ARM Cortex-A9 vs A8 performance
 ARM Thumb addressing modes
 ARM-unique instructions
 ARPA Advanced Research Project Agency LAN history
 ARPANET WAN history
 ASC Purple
 ASC see Advanced Simulation and Computing ASC program ASCI see Accelerated Strategic Computing Initiative ASCI ASCII character format
 ASCI White
 ASI see Advanced Switching Interconnect ASI ASPLOS see Architectural Support for Compilers and Operating Systems ASPLOS Assembly language
 ATA Advanced Technology Attachment disks Berkeley s Tertiary Disk project
 ATI Radeon
 ATM see Asynchronous Transfer Mode ATM ATM systems server benchmarks
 AVX for x86
 AVX instructions
 AVX see Advanced Vector Extensions AVX AWS see Amazon Web Services AWS B Back-off time shared-media networks
 Accelerated Strategic Computing Initiative ASCI ASCI Red
 Access
 Access bit IA-32 descriptor table
 Access time gap disk storage
 Access time see also Average Memory Access Time AMAT vs block size
 Active low power modes WSCs
 Ada language integer division remainder
 Adaptive routing definition
 Adders carry-lookahead
 Addition operations chip comparison
 Address Coalescing Unit function
 Address aliasing prediction definition
 Address fault virtual memory definition
 Address offset virtual memory
 Address space Fermi GPU architecture
 Address specifier instruction set encoding
 Address stage TI 320C55 DSP
 Address trace cache performance
 Address translation AMD64 paged virtual memory
 Addressing modes comparison
 Administrative costs WSC vs datacenters
 Adobe Photoshop multimedia support
 Advanced Research Project Agency see ARPA Advanced Research Project Agency Advanced RISC Machine see ARM Advanced RISC Machine Advanced Simulation and Computing ASC program system area network history
 Advanced Switching Interconnect ASI storage area network history
 Advanced Switching SAN
 Advanced Technology Attachment disks see ATA Advanced Technology Attachment disks Advanced Vector Extensions AVX double-precision FP programs
 Advanced directory protocol basic function
 Advanced load address table ALAT IA-64 ISA
 Advanced loads IA-64 ISA
 Advanced mobile phone service AMPS cell phones
 Affine loop-level parallelism dependences
 After rounding rule
 Aggregate bandwidth definition
 Aiken Howard
 Airflow containers
 Airside econimization WSC cooling systems
 Akamai as Content Delivery Network
 Aliased variables and compiler technology
 Aliases address translation
 Alignment memory address interpretation
 Allen Fran
 Alliant processors vector processor history
 Alpha
 Alpha-unique
 Alpha-unique instructions
 AltaVista search cluster history
 AltiVec multimedia instruction compiler support
 Amazon Elastic Computer Cloud EC2
 Amazon Simple Storage Service S3
 Amazon Web Services
 Amazon Web Services AWS cloud computing providers
 Amdahl Gene
 Amdahl s law
 Amdahl s law and parallel computers
 Amdahl s law computer design principles
 Amortization of overhead sorting case study
 Android OS
 Annulling delayed branch instructions
 Antenna radio receiver
 Antialiasing address translation
 Antidependences compiler history
 Apogee Software
 Apollo DN
 Apple iPad ARM Cortex-A8
 Application binary interface ABI control flow instructions
 Application layer definition
 Applied Minds
 Arbitration algorithm collision detection
 Architect-compiler writer relationship
 Architectural Support for Compilers and Operating Systems ASPLOS
 Architecturally visible registers register renaming vs ROB
 Architecture see also Computer architecture CUDA Compute Unified Device Architecture Instruction set architecture ISA V ector architectures compiler writer-architect relationship
 Areal density disk storage
 Argument pointer VAX
 Arithmetic intensity as FP operation
 Arithmetic logical instructions desktop RISCs
 Arithmetic-logical units ALUs ARM Cortex-A8
 Array multiplier example
 Array switch WSCs
 Arrays access age
 Association of Computing Machinery ACM
 Associativity see also Set associativity cache block
 Astronautics ZS-1
 Asynchronous I O storage systems
 Asynchronous Transfer Mode ATM interconnection networks
 Asynchronous events exception requirements
 Atanasoff Berry Computer ABC
 Atanasoff John
 Atlas computer
 Atom
 Atomic exchange lock implementation
 Atomic instructions barrier synchronization
 Atomic operations cache coherence
 Atomic swap definition
 Atomicity-consistency-isolation-durab ility ACID vs WSC storage
 Attributes field IA-32 descriptor table
 Autoincrement deferred addressing VAX
 Autonet
 Availability commercial interconnection networks
 Average Memory Access Time AMAT block size calculations
 Average instruction execution time
 Average reception factor centralized switched networks
 BARRNet see Bay Area Research Network BARRNet Based indexed addressing mode Intel 80x86
 BBN Butterfly
 BBN Monarch
 BER see Bit error rate BER Berkeley s Tertiary Disk project failure statistics
 BINAC
 BLT see Block transfer engine BLT Body of Vectorized Loop definition
 BOMB
 Backpressure congestion management
 Backside bus centralized shared-memory multiprocessors
 Balanced systems sorting case study
 Balanced tree MINs with nonblicking
 Bandwidth gap disk storage
 Bandwidth see also Throughput arbitration
 Banerjee Uptal
 Bank busy time vector memory systems
 Banked memory see also Memory banks and graphics memory
 Banks Fermi GPUs
 Barcelona Supercomputer Center
 Barnes characteristics
 Barriers commercial workloads
 Base field IA-32 descriptor table
 Base station cell phones
 Basic block ILP
 Batch processing workloads WSC goals requirements
 Bay Area Research Network BARRNet
 Before rounding rule
 Benchmarking see also specific benchmark suites desktop
 Benes networks
 Benes topology centralized switched networks
 Bens networks
 Berkeley s Tertiary Disk project
 Berners-Lee Tim
 Bertram Jack
 Best-case lower bounds multi-device interconnection networks
 Best-case upper bounds multi-device interconnection networks
 Between instruction exceptions definition
 Biased exponent
 Bidirectional multistage interconnection networks Benes topology
 Bidirectional rings topology
 Big Endian interconnection networks
 Bigtable Google
 Binary code compatibility embedded systems
 Binary-coded decimal definition
 Binary-to-decimal conversion FP precisions
 Bing search delays and user behavior
 Bisection bandwidth WSC array switch
 Bisection bandwidth as network cost constraint
 Bisection traffic fraction network performance and topology
 Bit error rate BER wireless networks
 Bit rot case study
 Bit selection block placement
 Black box network basic concept
 Block addressing block identification
 Block identification memory hierarchy considerations
 Block multithreading definition
 Block offset block identification
 Block placement memory hierarchy considerations
 Block replacement memory hierarchy considerations
 Block servers vs filers
 Block size vs access time
 Block transfer engine BLT Cray Research T3D
 Blocked floating point arithmetic DSP
 Blocking benchmark fallacies
 Blocking calls shared-memory multiprocessor workload
 Blocking factor definition
 Blocks see also Cache block Thread Block ARM Cortex-A8
 Boggs David
 Booth recoding
 Bose-Einstein formula definition
 Bounds checking segmented virtual memory
 Branch byte V AX
 Branch delay slot characteristics
 Branch folding definition
 Branch hazards basic considerations
 Branch history table basic scheme
 Branch offsets control flow instructions
 Branch penalty examples
 Branch prediction accuracy
 Branch registers IA-64
 Branch stalls MIPS R4000 pipeline
 Branch-prediction buffers basic considerations
 Branch-target address branch hazards
 Branch-target buffers ARM Cortex-A8
 Branch-target cache see Branch-target buffers Brewer Eric
 Branches canceling
 Bridges and bandwidth
 Bubble sort code example
 Bubbles and deadlock
 Buckets
 Buffered crossbar switch switch microarchitecture
 Buffered wormhole switching
 Bundles IA-64
 Burks Arthur
 Burroughs B5000
 Bus-based coherent multiprocessors Tomasulo s algorithm
 Buses
 Bypassing see also Forwarding data hazards requiring stalls
 Byte displacement addressing VAX
 Byte offset misaligned addresses
 Byte word long displacement deferred addressing VAX
 Bytes aligned misaligned addresses
 C CAC see Computer aided design CAD tools Cache bandwidth caches
 C mmp
 C program evaluation
 CACTI cache optimization
 CAPEX see Capital expenditures CAPEX Capital expenditures CAPEX WSC costs
 CAS see Column access strobe CAS Case statements control flow instruction addressing modes
 CCD see Charge-coupled device CCD C C language dependence analysis
 CDB see Common data bus CDB CDC see Control Data Corporation CDC CDF datacenter
 CDMA see Code division multiple access CDMA Cedar project
 CERN see European Center for Particle Research CERN CFM see Current frame pointer CFM Chaining convoys DAXPY code
 CIFS see Common Internet File System CIFS Circuit switching congestion management
 CISC see Complex Instruction Set Computer CISC CL A see Carry-lookahead adder CLA Clean block definition
 CMOS DRAM
 COLOSSUS
 COMA see Cache-only memory architecture COMA Combining tree large-scale multiprocessor synchronization
 CP-67 program
 CPA see Carry-propagate adder CPA CPI see Clock cycles per instruction CPI CPU see Central processing unit CPU CRAC see Computer room air-conditioning CRAC Cray Seymour
 CPI and FP
 CPI and IPC
 CPI calculations
 CPU time equation
 CRC see Cyclic redundancy check CRC Create vector index instruction CVI sparse matrices
 CRISP
 CSA see Carry-save adder CSA Carry-skip adder CSA C language hardware impact on software development
 CSSU see Compare-select-store unit CSSU CUDA Compute Unified Device Architecture GPU computing history
 CUDA
 CUDA Thread
 CUDA Thread CUDA programming model
 CUDA parallelism
 CUDA program
 CVI see Create vector index instruction CVI CWS see Circulating water system CWS CYBER
 CYBER
 Cache block AMD Opteron data cache
 Cache coherence advanced directory protocol case study
 Cache definition
 Cache hit AMD Opteron example
 Cache latency nonblocking cache
 Cache miss and average memory access time
 Cache optimizations basic categories
 Cache organization blocks
 Cache performance average memory access time
 Cache prefetch cache optimization
 Cache size and access time
 Cache-only memory architecture COMA
 Caches see also Memory hierarchy access time vs block size
 Call gate IA-32 segment descriptors
 Caller saving control flow instructions
 Calls compiler structure
 Canceling branch branch delay slots
 Canonical form AMD64 paged virtual memory
 Capabilities protection schemes
 Carrier sensing shared-media networks
 Carrier signal wireless networks
 Carry condition code MIPS core
 Carry-in carry-skip adder
 Carry-lookahead adder CLA chip comparison
 Carry-out carry-lookahead circuit
 Carry-propagate adder CPA integer multiplication
 Carry-save adder CSA integer division
 Carry-select adder characteristics
 Carry-skip adder CSA characteristics
 Case studies advanced directory protocol
 Cell Barnes-Hut n-body algorithm
 Cell phones block diagram
 Central processing unit CPU Amdahl s law
 Central processing unit CPU time execution time
 Centralized shared-memory multiprocessors basic considerations
 Centralized switched networks example
 Centrally buffered switch microarchitecture
 Cerf Vint
 Channel adapter see Network interface Channels cell phones
 Character floating-point performance
 Charge-coupled device CCD Sanyo VPC-SX500 digital Index
 Checksum
 Chillers Google WSC
 Chime definition
 Chip-crossing wire delay
 Chipkill memory dependability
 Choke packets congestion management
 Chunk disk array deconstruction
 Circulating water system CWS cooling system design
 Climate Savers Computing Initiative power supply efficiencies
 Clock cycle time and associativity
 Clock cycles basic MIPS pipeline
 Clock cycles per instruction CPI addressing modes
 Clock periods processor performance equation
 Clock rate DDR DRAMS and DIMMS
 Clock skew pipelining performance
 Clock ticks cache coherence
 Clocks processor performance equation
 Clos network Benes topology
 Cloud computing basic considerations
 Clusters characteristics
 Cm
 Coarse-grained multithreading definition
 Cocke John
 Code division multiple access CDMA cell phones
 Code generation compiler structure
 Code scheduling example
 Code size architect-compiler considerations
 Coefficient of variance
 Coerced exceptions definition
 Coherence see Cache coherence Coherence misses definition
 Cold-start misses definition
 Collision detection shared-media networks
 Collision misses definition
 Collision shared-media networks
 Collocation sites interconnection networks
 Column access strobe CAS DRAM
 Column major order blocking
 Command queue depth vs disk throughput
 Commercial interconnection networks congestion management
 Commercial workloads execution time distribution
 Commit stage ROB instruction
 Commodities Amazon Web Services
 Commodity cluster characteristics
 Common Internet File System CIFS
 Common data bus CDB dynamic scheduling with Tomasulo s algorithm
 Communication bandwidth basic considerations
 Communication latency basic considerations
 Communication latency hiding basic considerations
 Communication mechanism adaptive routing
 Communication protocol definition
 Communication subnets see Interconnection networks Communication subsystems see Interconnection networks Compare instruction V AX
 Compare-select-store unit CSSU TI TMS320C55 DSP
 Compares MIPS core
 Compiler optimizations blocking
 Compiler scheduling data dependences
 Compiler speculation hardware support memory references
 Compiler techniques dependence analysis
 Compiler technology and architecture decisions
 Compiler writer-architect relationship
 Compiler-controlled prefetching miss penalty rate reduction
 Complex Instruction Set Computer CISC RISC history
 Compulsory misses and cache size
 Computation-to-communication ratios parallel programs
 Compute Unified Device Architecture see CUDA Compute Unified Device Architecture Conditional branches branch folding
 Compute tiles OCNs
 Compute-optimized processors interconnection networks
 Computer aided design CAD tools cache optimization
 Computer architecture see also Architecture coining of term
 Computer arithmetic chip comparison
 Computer chip fabrication cost case study
 Computer classes desktops
 Computer design principles Amdahl s law
 Computer history technology and architecture
 Computer room air-conditioning CRAC WSC infrastructure
 Condition codes branch conditions
 Conditional instructions exposing parallelism
 Conflict misses and block size
 Congestion control commercial interconnection networks
 Congestion management commercial interconnection networks
 Connectedness dimension-order routing
 Connection Machine CM-5
 Connection Multiprocessor
 Connection delay multi-device interconnection networks
 Consistency see Memory consistency Constant extension desktop RISCs
 Constellation characteristics
 Containers airflow
 Context Switching definition
 Control Data Corporation CDC
 Control Data Corporation CDC STAR processor
 Control Data Corporation CDC STAR-100 first vector computers
 Control Data Corporation CDC first vector computers
 Control Processor definition
 Control Protocol Internet Protocol TCP IP ATM
 Control bits messages
 Control dependences conditional instructions
 Control flow instructions addressing modes
 Control hazards ARM Cortex-A8
 Control instructions Intel 80x86
 Controller transitions directory-based
 Controllers historical background
 Conventional datacenters vs WSCs
 Convex Exemplar
 Convex processors vector processor history
 Convolution DSP
 Convoy chained DAXPY code
 Conway Lynn
 Cooling systems Google WSC
 Copper wiring Ethernet
 Coprocessor operations MIPS core extensions
 Copy propagation definition
 Core definition
 Core i7
 Core plus ASIC embedded systems
 Correlating branch predictors branch costs
 Cosmic Cube
 Cost Amazon EC2
 Cost associativity cloud computing
 Cost trends integrated circuits
 Cost-performance commercial interconnection networks
 Count register PowerPC instructions
 Cray C90 first vector computers
 Cray J90
 Cray Research T3D
 Cray T3D
 Cray T3E
 Cray T90 memory bank calculations
 Cray X-MP
 Cray X1
 Cray X1 MSP modules
 Cray X1 cluster history
 Cray X1E
 Cray X2
 Cray XT3
 Cray XT3 SeaStar
 Cray Y -MP first vector computers
 Cray supercomputers early computer arithmetic
 Cray-1 first vector computers
 Cray-2 DRAM
 Cray-3
 Cray-4
 Credit-based control flow InfiniBand
 Critical path global code scheduling
 Critical word first cache optimization
 Cross-company interoperability commercial interconnection networks
 Crossbar switch centralized switched networks
 Crossbars centralized switched networks
 Crusoe
 Cryptanalysis
 Current frame pointer CFM IA-64 register model
 Custom cluster characteristics
 Cut-through packet switching
 Cycle time see also Clock cycle time CPI calculations
 Cycles processor performance equation
 Cyclic redundancy check CRC IBM Blue Gene L 3D torus network
 Cydrome Cydra
 D DaCapo benchmarks ISA
 D-caches case study examples
 DAMQs see Dynamically allocatable multi-queues DAMQs DASH multiprocessor
 DAXPY
 DAXPY loop chained convoys
 DAXPY on VMIPS
 DDR DRAMS and DIMMS
 DDR see Double data rate DDR Deadlock cache coherence
 DDR2 SDRAM timing diagram
 DDR3 DRAM internal organization
 DDR3 SDRAM
 DDR4 DRAM
 DDR5 GDRAM
 DEC PDP-11 address space
 DEC VAX
 DEC VAX Index
 DEC VAX-11
 DECstation
 DIMMs see Dual inline memory modules DIMMs Direct attached disks definition
 DLP
 DLP basic considerations
 DLP processors
 DLP see Data-level parallelism DLP DLX integer arithmetic
 DLP see Data-level parallelism DLP Ethernet
 DMA see Direct memory access DMA DOR see Dimension-order routing DOR Double data rate DDR ARM Cortex-A8
 DOR
 DPL see Descriptor privilege level DPL DRAM see Dynamic random-access memory DRAM DRDRAM Sony PlayStation
 DRAM
 DRAM and DIMM characteristics
 DRAM basics
 DRAM magnetic disk
 DRAM magnetic disk cost vs access time
 DRAM performance
 DRAMs and DIMMS
 DSM
 DSM and directory-based coherence
 DSM architecture
 DSM implementation
 DSM multiprocessor
 DSM multiprocessor cache coherence
 DSM see Distributed shared memory DSM DSP see Digital signal processor DSP DSS see Decision support system DSS Dual inline memory modules DIMMs clock rates bandwidth names
 DSP
 DSP extensions
 DSP media extensions
 DSPs
 DVFS
 DVFS see Dynamic voltage-frequency scaling DVFS Dynamically allocatable multi-queues DAMQs switch microarchitecture
 Data cache ARM Cortex-A8
 Data cache miss applications vs OS
 Data cache size multiprogramming
 Data dependences conditional instructions
 Data fetching ARM Cortex-A8
 Data flow control dependence
 Data flow execution hardware-based speculation
 Data link layer definition
 Data parallelism SIMD computer history
 Data races synchronized programs
 Data transfers cache miss rate calculations
 Data trunks MIPS scoreboarding
 Data types architect-compiler writer relationship
 Data-level parallelism DLP definition
 Data-race-free synchronized programs
 Database program speculation via multiple branches
 Datacenters CDF
 Datagrams see Packets Data hazards ARM Cortex-A8
 Dauber Phil
 Dead time vector pipeline
 Deadlock avoidance meshes and hypercubes
 Deadlock recovery routing
 Decimal operands formats
 Decimal operations PA-RISC instructions
 Decision support system DSS shared-memory workloads
 Decode stage TI 320C55 DSP
 Decoder radio receiver
 Dedicated link network black box network
 Defect tolerance chip fabrication cost case study
 Deferred addressing VAX
 Delayed branch basic scheme
 Dell PowerEdge servers
 Dell Poweredge Thunderbird SAN characteristics
 Dell Poweredge servers prices
 Dell servers
 Dell servers economies of scale
 Demodulator radio receiver
 Denormals
 Dense matrix multiplication LU kernel
 Density-optimized processors vs SPEC-optimized
 Dependability benchmark examples
 Dependence analysis basic approach
 Dependence distance loop-carried dependences
 Dependences antidependences
 Dependent computations elimination
 Descriptor privilege level DPL segmented virtual memory
 Descriptor table IA-32
 Design faults storage systems
 Desktop computers characteristics
 Destination offset IA-32 segment Deterministic routing algorithm vs adaptive routing
 Die yield basic equation
 Dies embedded systems
 Digital Alpha
 Digital Alpha MAX characteristics
 Digital Alpha branches
 Digital Alpha processors addressing modes
 Digital Linear Tape
 Digital signal processor DSP cell phones
 Dimension-order routing DOR definition
 Direct memory access DMA historical background
 Direct networks commercial system topologies
 Direct-mapped cache address parts
 Directory controller cache coherence
 Directory-based cache coherence advanced directory protocol case study
 Directory-based multiprocessor characteristics
 Dirty bit case study
 Dirty block definition
 Discrete cosine transform DSP
 Disk arrays deconstruction case study
 Disk layout RAID performance prediction
 Disk power basic considerations
 Disk storage access time gap
 Disk technology failure rate calculation
 Dispatch stage instruction steps
 Displacement addressing mode basic considerations
 Display lists Sony PlayStation
 Distributed routing basic concept
 Distributed shared memory DSM basic considerations
 Distributed shared-memory multiprocessors cache coherence implementation
 Distributed switched networks topology
 Divide operations chip comparison
 Double data rate
 Double failures RAID reconstruction
 Double rounding FP precisions
 Double words aligned misaligned addresses
 Double-extended floating-point arithmetic
 Double-precision floating point add-divide
 Driver domains Xen VM
 Dual SIMD Thread Scheduler example
 Dynamic energy definition
 Dynamic network reconfiguration fault tolerance
 Dynamic power energy efficiency
 Dynamic random-access memory DRAM bandwidth issues
 Dynamic scheduling first use
 Dynamic voltage-frequency scaling DVFS energy efficiency
 Dynamically scheduled pipelines basic considerations
 Dynamically shared libraries control flow instruction addressing modes
 Dynamo
 Dynamo Amazon
 E Early restart miss penalty reduction
 EBS see Elastic Block Storage EBS EC2 see Amazon Elastic Computer Cloud EC2 ECC see Error-Correcting Code ECC Eckert J Presper
 ECL minicomputer
 EDSAC Electronic Delay Storage Automatic Calculator
 EDVAC Electronic Discrete Variable Automatic Computer
 EEMBC
 EEMBC benchmark suite
 EEMBC benchmarks
 EEMBC see Electronic Design News Embedded Microprocessor Benchmark Consortium EEMBC EEPROM Electronically Erasable Programmable Read-Only Memory compiler-code size considerations
 EMC
 ENIAC Electronic Numerical Integrator and Calculator
 EPIC
 EPIC approach historical background
 ERA see Engineering Research Associates ERA Erasure encoding WSCs
 ETA processor vector processor history
 EVEN-ODD scheme development
 EX see Execution address cycle EX Example calculations average memory access time
 Earth Simulator
 Eckert-Mauchly Computer Corporation
 Economies of scale WSC vs datacenter costs
 Effective address ALU
 Effective bandwidth definition
 Efficiency factor
 Eight-way set associativity ARM Cortex-A8
 Elapsed time execution time
 Elastic Block Storage EBS MapReduce cost calculations
 Electronic Design News Embedded Microprocessor Benchmark Consortium EEMBC benchmark classes
 Electronic Discrete Variable Automatic Computer EDVAC
 Electronic Numerical Integrator and Calculator ENIAC
 Electronically Erasable Programmable Read-Only Memory see EEPROM Electronically Erasable Programmable Read-Only Memory Electronic Delay Storage Automatic Calculator EDSAC
 Element group definition
 Embedded multiprocessors characteristics
 Embedded systems benchmarks basic considerations
 Emotion Engine
 Emotion Engine case study
 Emotion Engine organization
 Emotion Engine organization modes
 Encoding control flow instructions
 Encore Multimax
 End-to-end flow control congestion management
 Energy efficiency see also Power consumption Climate Savers Computing Initiative
 Energy proportionality WSC servers
 Engineering Research Associates ERA
 Enigma coding machine
 Entry time transactions
 Environmental faults storage systems
 Equal condition code PowerPC
 Error handling interconnection networks
 Error-Correcting Code ECC disk storage
 Errors definition
 Escape resource set
 Ethernet
 Ethernet A TM total time
 Ethernet and bandwidth
 Ethernet and bridges
 Ethernet as
 Ethernet rack switch
 Ethernet switches architecture considerations
 European Center for Particle Research CERN
 Even odd array example
 Exceptions ALU instructions
 Execute step instruction steps
 Execution address cycle EX basic MIPS pipeline
 Execution time Amdahl s law
 Expand-down field
 Explicit operands ISA classifications
 Explicit parallelism IA-64
 Explicit unit stride GPUs vs vector architectures
 Exponential back-off large-scale multiprocessor synchronization
 Exponential distribution definition
 Extended accumulator flawed architectures
 Extreme
 F Facebook
 FC see Fibre Channel FC FC-AL see Fibre Channel Arbitrated Loop FC-AL FC-SW see Fibre Channel Switched FC-SW Feature size dependability
 FEC see Forward error correction FEC Federal Communications Commission FCC telephone company outages
 FFT
 FFT kernel
 FFT see Fast Fourier transformation FFT Fibre Channel FC
 FIFO see First-in first-out FIFO Filers vs block servers
 FIT rates WSC memory
 FLASH multiprocessor
 FM see Frequency modulation FM Form factor interconnection networks
 FORTRAN compiler vectorization
 FORTRAN test kernels
 FP arithmetic
 FP benchmarks
 FP conversions
 FP instructions
 FP operations
 FP pipeline
 FP pipeline performance
 FP precisions
 FP register file
 FP see Floating-point FP operations FPGAs see Field-programmable gate arrays FPGAs FPRs see Floating-point registers FPRs FPSQR see Floating-point square root FPSQR Frame pointer VAX
 FP standard
 FP underflow
 FP unit
 FP unit using Tomasulo s algorithm
 FP unit with T omasulo s algorithm
 FP unit with Tomasulo s algorithm
 FU see Functional unit FU Fujitsu Primergy BX3000 blade server
 Failures see also Mean time between failures MTBF Mean time to failure MTTF Amdahl s law
 False sharing definition
 FarmVille
 Fast Fourier transformation FFT characteristics
 Fast traps SPARC instructions
 Fat trees definition
 Fault detection pitfalls
 Fault tolerance and adaptive routing
 Fault-induced deadlock routing
 Fault-tolerant routing commercial interconnection networks
 Faulting prefetches cache optimization
 Faults see also Exceptions Page faults address fault
 Fermi GPU
 Fermi GPU architectural innovations
 Fermi GPU architecture
 Fermi GPU architecture innovations
 Fermi GPU block diagram
 Fermi GPU comparison
 Fermi GTX
 Fermi Tesla GPU computing history
 Fermi Tesla GTX
 Fetch-and-increment large-scale multiprocessor synchronization
 Fetching see Data fetching Fetch stage TI 320C55 DSP
 Fibre Channel Arbitrated Loop FC-AL
 Fibre Channel Switched FC-SW
 Field-programmable gate arrays FPGAs WSC array switch
 Filer servers SPEC benchmarking
 Filters radio receiver
 Fine-grained multithreading definition
 Fingerprint storage system
 Finite-state machine routing implementation
 Firmware network interfaces
 First-in first-out FIFO block replacement
 First-level caches see also L1 caches ARM Cortex-A8
 First-reference misses definition
 Fixed-field decoding simple RISC implementation
 Fixed-length encoding general-purpose registers
 Fixed-length vector SIMD
 Fixed-point arithmetic DSP
 Flags performance benchmarks
 Flash Memory
 Flash memory
 Flash memory characteristics
 Flexible chaining vector execution time
 Floating Point Systems AP-120B
 Floating-point FP operations addition denormals
 Floating-point registers FPRs IA-64
 Floating-point square root FPSQR calculation
 Floppy disks
 Flow control and arbitration
 Flow-balanced state
 Fluent
 Flush branch penalty reduction
 Forward error correction FEC DSP
 Forward path cell phones
 Forwarding see also Bypassing ALUs
 Forwarding table routing implementation
 Four-way conflict misses definition
 Fourier transform DSP
 Fourier-Motzkin algorithm
 Freeze branch penalty reduction
 Frequency modulation FM wireless neworks
 Front-end stage Itanium
 Fujitsu VP100
 Fujitsu VP200
 Full access dimension-order routing
 Full adders
 Fully associative cache block placement
 Fully connected topology distributed switched networks
 Function calls GPU programming
 Function pointers control flow instruction addressing modes
 Functional hazards ARM Cortex-A8
 Functional unit FU FP operations
 Fused multiply-add floating point
 Future file precise exceptions
 G Gateways Ethernet
 GCD
 GCD see Greatest common divisor GCD test GDDR see Graphics double data rate GDDR
 GCD test
 GDRAM
 GDRAM see Graphics dynamic random-access memory GDRAM GE
 GDRAMs
 GENI see Global Environment for Network Innovation GENI Geometric means example calculations
 GFS see Google File System GFS Gibson mix
 GPGPU General-Purpose Computing on GPUs
 GPR advantages disadvantages
 GPRs see General-purpose registers GPRs GPU Graphics Processing Unit banked and graphics memory
 GPU
 GPU ISA
 GPU Memory
 GPU Memory performance
 GPU Memory structure
 GPU Memory structures
 GPU SIMD instructions
 GPU comparison
 GPU comparisons
 GPU computation
 GPU computational structures
 GPU computing history
 GPU conditional branching
 GPU data addresses
 GPU examples
 GPU features
 GPU flooplan
 GPU floorplan
 GPU hardware
 GPU hardware levels
 GPU issues
 GPU programming
 GPU terminology
 GPU terms
 GPU threads
 GPU vs MIMD
 GPU vs MIMD with Multimedia SIMD
 GPUs
 GPUs and coprocessors
 GPUs as coprocessors
 GPUs basic considerations
 GPUs vs vector architectures
 GSDRAM see Graphics synchronous dynamic random-access memory GSDRAM GSM see Global system for mobile communication GSM Guest definition
 GTX
 Gather-Scatter definition
 General-Purpose Computing on GPUs GPGPU
 General-purpose electronic computers historical background
 General-purpose registers GPRs advantages disadvantages
 Giga Thread Engine definition
 Global Environment for Network Innovation GENI
 Global Memory definition
 Global Positioning System CDMA
 Global address space segmented virtual memory
 Global code scheduling example
 Global common subexpression elimination compiler structure
 Global data area and compiler technology
 Global load store definition
 Global miss rate definition
 Global optimizations compilers
 Global predictors Intel Core i7
 Global scheduling ILP VLIW processor
 Global system for mobile communication GSM cell phones
 Goldschmidt s division algorithm
 Goldstine Herman
 Google App Engine
 Google Bigtable
 Google Clusters memory dependability
 Google File System GFS MapReduce
 Google Goggles PMDs
 Google WSC
 Google WSC containers
 Google WSC networking
 Google WSC server
 Google WSC servers
 Google WSCs
 Google containers
 Google search
 Google search shared-memory workloads
 Google server benchmarks
 Google server usage
 Google usage
 Gordon Bell Prize
 Gradual underflow
 Grain size MIMD
 Grant phase arbitration
 Graph coloring register allocation
 Graphics Processing Unit see GPU Graphics Processing Unit Graphics synchronous dynamic random-access memory GSDRAM characteristics
 Graphics Synthesizer Sony PlayStation
 Graphics double data rate GDDR characteristics
 Graphics dynamic random-access memory GDRAM bandwidth issues
 Graphics pipelines historical background
 Graphics-intensive benchmarks desktop performance
 Greater than condition code PowerPC
 Greatest common divisor GCD test loop-level parallelism dependences
 Grid arithmetic intensity
 Grid computing
 Grid mapping
 Grid topology characteristics
 Guest domains Xen VM
 H Hadoop WSC batch processing
 HCAs see Host channel adapters HCAs messages
 HEP processor
 HLLCA see High-level language computer architecture HLLCA HOL see Head-of-line blocking HOL Home node directory-based cache coherence protocol basics
 HOL blocking
 HOL see Head-of-line HOL blocking network performance and topology
 HP-Compaq servers price-performance differences
 HPC hardware
 HPC see High-performance computing HPC HPC Challenge vector processor history
 HPSm
 Half adders
 Half words aligned misaligned addresses
 Handshaking interconnection networks
 Hard drive power consumption
 Hard real-time systems definition
 Hardware as architecture component
 Hardware faults storage systems
 Hardware prefetching cache optimization
 Hardware primitivies basic types
 Hardware-based speculation basic algorithm
 Harvard architecture
 Hazards see also Data hazards branch hazards
 Head-of-line HOL blocking congestion management
 Header packet format
 Heap and compiler technology
 Heterogeneous architecture definition
 Hewlett-Packard AlphaServer
 Hewlett-Packard PA-RISC MAX2 multimedia support
 Hewlett-Packard PA-RISC addressing modes
 Hewlett-Packard Precision Architecture integer arithmetic
 Hewlett-Packard ProLiant BL10e G2 Blade server
 Hewlett-Packard ProLiant SL2x170z G6 SPECPower benchmarks
 Hewlett-Packard RISC microprocessors vector processor history
 High-level language computer architecture HLLCA
 High-level optimizations compilers
 High-order functions control flow instruction addressing modes
 High-performance computing HPC InfiniBand
 Higher-radix division
 Higher-radix multiplication integer
 Highly parallel memory systems case studies
 Hillis Danny
 Histogram
 History file precise exceptions
 Hit time average memory access time
 Hitachi S810
 Hitachi SuperH addressing modes
 Hop count definition
 Hops direct network topologies
 Host channel adapters HCAs historical background
 Host definition
 Hot swapping fault tolerance
 HyperTransport
 Hypercube networks characteristics
 Hypertransport AMD Opteron cache coherence
 Hypervisor characteristics
 I IAS machine
 I O bandwidth definition
 I O benchmarks response time restrictions
 I O bound workload Virtual Machines protection
 I O bus historical background
 I O bus history
 I O bus replacements
 I O cache coherency basic considerations
 I O devices
 I O devices address translation
 I O interfaces disk storage
 I O latency shared-memory workloads
 I O network commercial interconnection network connectivity
 I O registers write buffer merging
 I O subsystem design
 I O subsystems design
 I O system as black blox
 I O system design evaluation
 I O system utilization
 I O systems IP asynchronous
 IA-32 equivalent
 IA-32 segment
 IA-32 segment descriptors
 IA-64
 IA-64 ISA
 IA-64 functional units and instruction issue
 IA-64 instruction format
 IA-64 instruction formats
 IA-64 instructions
 IA-64 register model
 IBM
 IBM AS
 IBM Blue Gene L
 IBM Blue Gene L 3D torus network
 IBM Chipkill
 IBM CodePack RISC code size
 IBM CoreConnect cross-company interoperability
 IBM Federation network interfaces
 IBM J9 JVM real-world server considerations
 IBM PCs architecture flaws vs success
 IBM Power
 IBM Power processors
 IBM Power processors branch-prediction buffers
 IBM Power7
 IBM Pulsar processor
 IBM RP3
 IBM RS
 IBM RT-PC
 IBM SAGE
 IBM Stretch
 IBM eServer p5
 IBM eServer p5 multiprocessor
 IBM eServer p5 processor
 IBM eServer p5 processor performance cost benchmarks
 IBM servers economies of scale
 IBM zSeries vector processor history
 IC see Instruction count IC I-caches case study examples
 ICR see Idle Control Register ICR ID see Instruction decode ID Ideal pipeline cycles per instruction ILP concepts
 IDE disks Berkeley s Tertiary Disk project
 IEEE
 IEEE arithmetic floating point
 IEEE standard
 IF see Instruction fetch IF cycle IF statement handling control dependences
 ILP
 ILP approaches
 ILP basic concept
 ILP concepts
 ILP considerations
 ILP data flow execution
 ILP exploitation
 ILP exposure
 ILP for realizable processors
 ILP hardware model
 ILP in perfect processor
 ILP instruction bandwidth basic considerations
 ILP instruction fetch basic considerations
 ILP limitation studies
 ILP limitations
 ILP see Instruction-level parallelism ILP Immediate addressing mode ALU operations
 ILP see Instruction-level parallelism ILP loop-level
 ILP speculative execution
 ILP studies
 ILP without multithreading
 IMPACT
 IMT-2000 Inactive power modes WSCs
 IMT-2000 cell phone standards
 IMT-2000 see International Mobile Telephony
 IOP see I O processor IOP I O processor IOP first dynamic scheduling
 IR see Instruction register IR ISA see Instruction set architecture ISA Index
 ISA
 ISA and code size
 ISA and compiler technology
 ISA class
 ISA classification
 ISA code size
 ISA components
 ISA example addressing modes for data transfer
 ISA instruction formats
 ISA operands
 ISA performance and efficiency Itanium
 ISA performance and efficiency prediction
 ISA support
 ISAs
 Ideal processors ILP hardware model
 Idle Control Register ICR TI TMS320C55 DSP
 Idle domains TI TMS320C55 DSP
 Illiac IV
 Implicit operands ISA classifications
 Implicit unit stride GPUs vs vector architectures
 Imprecise exceptions data hazards
 In flight instructions ILP hardware model
 In-order commit hardware-based speculation
 In-order execution average memory access time
 In-order floating-point pipeline dynamic scheduling
 In-order issue ARM Cortex-A8
 In-order scalar processors VMIPS
 Inclusion cache hierarchy
 Index
 Index Addressing modes continued displacement mode
 Index Arithmetic-logical units continued pipeline branch issues
 Index Barnes-Hut n-body algorithm basic concept
 Index Buffers branch-prediction
 Index Capacity misses blocking
 Index Clock cycles per instruction continued extensive pipelining
 Index Computer architecture continued definition
 Index Cost continued I O system design evaluation
 Index Data hazards stall minimization by forwarding
 Index Dependences continued loop-level parallelism
 Index Double-precision continued Roofline model
 Index Encoding continued ISAs
 Index Execution time continued performance equations
 Index Floating-point operations continued pipeline hazards and forwarding dependence analysis
 Index GPU Memory caches
 Index IBM
 Index ISCA see International Computer Architecture Symposium ISCA iSCSI NetApp FAS6000 filer
 Index Instruction decode continued simple MIPS implementation
 Index Integer arithmetic continued carry-skip adder
 Index Intel Streaming SIMD Extension SSE basic function
 Index Layer
 Index MIPS64 continued conditional branches
 Index Main Memory continued processor performance calculations
 Index Memory protection continued safe calls
 Index Multilevel caches continued Multimedia SIMD vs GPU
 Index Networking costs WSC vs datacenters
 Index OPEX see Operational expenditures OPEX Optical media interconnection networks
 Index Pascal programs compiler types and classes
 Index Pipeline latches ALU
 Index Primitives architect-compiler writer relationship
 Index RDMA see Remote direct memory access RDMA Read after read RAR absence of data hazard
 Index Response time see also Latency I O benchmarks
 Index SIMD continued GPU examples
 Index SPEC benchmarks continued processor performance growth
 Index Scripting languages software development impact
 Index Stall cycles continued definition
 Index Supercomputers continued low-dimensional topologies
 Index TCO see Total Cost of Ownership TCO TCP see Transmission Control Protocol TCP TCP IP see Transmission Control Protocol Internet Protocol TCP IP TDMA see Time division multiple access TDMA TDP see Thermal design power TDP Technology trends basic considerations
 Index Trailer messages
 Index Variables continued CUDA
 Index Virtual output queues VOQs switch microarchitecture
 Index Write-back cycle continued execution sequences
 Index field block identification
 Index vector gather scatter operations Indirect addressing V AX
 Indexed addressing Intel 80x86
 Indexes address translation during
 Indirect networks definition
 Inexact exception floating-point arithmetic
 InfiniBand
 InfiniBand example
 Infinite population model queuing model
 Information tables examples
 Infrastructure costs WSC
 Initiation interval MIPS pipeline FP operations
 Initiation rate floating-point pipeline
 Inktomi
 Input buffered switch HOL blocking
 Input-output buffered switch microarchitecture
 Instruction cache AMD Opteron example
 Instruction commit hardware-based speculation
 Instruction count IC addressing modes
 Instruction decode ID basic MIPS pipeline
 Instruction delivery stage Itanium
 Instruction fetch IF cycle basic MIPS pipeline
 Instruction fetch units integrated
 Instruction formats ARM-unique
 Instruction groups IA-64
 Instruction issue definition
 Instruction path length processor performance time
 Instruction prefetch integrated instruction fetch units
 Instruction register IR basic MIPS pipeline
 Instruction set architecture ISA see also Intel 80x86 processors Reduced Instruction Set Computer RISC addressing modes
 Instruction status dynamic scheduling
 Instruction-level parallelism ILP ARM Cortex-A8
 Instructions per clock IPC ARM Cortex-A8
 Integer arithmetic addition speedup carry-lookahead
 Integer operand flawed architecture
 Integer operations addressing modes
 Integer registers hardware-based speculation
 Integrated circuit basics cell phones
 Intel
 Intel 80x86
 Intel 80x86 instruction lengths
 Intel 80x86 instruction mix
 Intel 80x86 instructions
 Intel 80x86 integer operations
 Intel 80x86 operand type distribution
 Intel 80x86 operands
 Intel 80x86 operations
 Intel 80x86 processors address encoding
 Intel 80x86 registers
 Intel 80x86 virtualization issues
 Intel AVX
 Intel Atom
 Intel Atom processors ISA performance and efficiency prediction
 Intel Core i7
 Intel Core i7 TLB structure
 Intel Core i7 branch predictor
 Intel Core i7 continued single-threaded benchmarks
 Intel Core i7 memory
 Intel Core i7 performance energy efficiency
 Intel Core i7 three-level cache hierarchy
 Intel Core i7 vs Alpha processors
 Intel IA-32 architecture call gate
 Intel IA-64 architecture compiler scheduling history
 Intel Itanium
 Intel Itanium sparse matrices
 Intel MMX multimedia instruction compiler support
 Intel Nehalem characteristics
 Intel Paragon
 Intel Pentium
 Intel Pentium II
 Intel Pentium III pipelined cache access
 Intel Pentium Intel Pentium Intel Pentium Intel Pentium M power consumption
 Intel Pentium protection
 Intel SCCC
 Intel Single-Chip Cloud Computing SCCC as interconnection example
 Intel Teraflops processors OCNs
 Intel Thunder Tiger
 Intel VT-x
 Intel Xeon Amazon Web Services
 Intel i860
 Intel iPSC
 Intel processors early RISC designs
 Intel support
 Intel x86 Amazon Web Services
 Intelligent devices historical background
 Interactive workloads WSC goals requirements
 Interarrival times queuing model
 Interconnection networks adaptive routing
 Intermittent faults storage systems
 Internal Mask Registers definition
 Internal fragmentation virtual memory page size selection
 International Computer Architecture Symposium ISCA
 International Mobile Telephony
 Internet Amazon Web Services
 Internet Archive Cluster
 Internet Archive Cluster container history
 Internet Archive Cluster see Internet Archive Cluster I O performance
 Internet Archive Cluster see Internet Archive Cluster large-scale multiprocessors
 Internet Archive Cluster see Internet Archive Cluster multithreading history
 Internet Protocol IP cores OCNs
 Internet Protocol IP internetworking
 Internet Protocol IP routers VOQs
 Internetworking connection example
 Interprocedural analysis basic approach
 Interprocessor communication large-scale multiprocessors
 Interrupt see Exceptions Invalidate protocol directory-based cache coherence protocol example
 Invalid exception floating-point arithmetic
 Inverted page table virtual memory block identification
 Issue logic ARM Cortex-A8
 Issue stage ID pipe stage
 Itanium
 Iterative division floating point
 J Java benchmarks Intel Core i7
 JBOD see RAID
 JVM see Java Virtual Machine JVM K Kahle Brewster
 Java Virtual Machine JVM early stack architectures
 Java and PARSEC without SMT
 Java and PARSEC workloads
 Java benchmarks
 Java language dependence analysis
 Johnson Reynold B
 Jump prediction hardware model
 Jumps control flow instructions
 Just-in-time JIT
 Kahn Robert
 Kendall Square Research KSR-1
 Kernels arithmetic intensity
 L L1 caches see also First-level caches address translation
 L1 cache speed
 L2 L3 miss rates
 L2 caches continued multithreading
 L2 caches see also Second-level caches ARM Cortex-A8
 L3 cache block size
 L3 cache size misses per instruction
 L3 caches
 L3 caches see also Third-level caches Alpha
 LAN history
 LANs
 LANs see Local area networks LANs Large-scale multiprocessors cache coherence implementation deadlock and buffering
 LCA see Least common ancestor LCA LCD see Liquid crystal display LCD Learning curve cost trends
 LISP
 LISP RISC history
 LMD see Load memory data LMD Load instructions control dependences
 LRU
 LRU see Least recently used LRU Lucas compiler optimizations
 LU
 LU kernel
 LUI see Load upper immediate LUI LU kernel M characteristics
 LabVIEW embedded benchmarks
 Lampson Butler
 Lanes GPUs vs vector architectures
 Latency see also Response time advanced directory protocol case study
 Layer
 Least common ancestor LCA routing algorithms
 Least recently used LRU AMD Opteron data cache
 Less than condition code PowerPC
 Level
 Limit field IA-32 descriptor table
 Line locking embedded systems
 Line memory hierarchy basics
 Linear speedup cost effectiveness
 Link injection bandwidth calculation
 Link pipelining definition
 Link reception bandwidth calculation
 Link register MIPS control flow instructions
 Linpack benchmark cluster history
 Linux operating systems Amazon Web Services
 Liquid crystal display LCD Sanyo VPC-SX500 digital camera
 Lisp ILP
 Literal addressing mode basic considerations
 Little Endian Intel 80x86
 Little s law
 Little s law definition
 Livelock network routing
 Liveness control dependence
 Livermore Fortran kernel performance
 Livermore Fortran kernels
 Livermore Fortran kernels performance
 Load interlocks definition
 Load linked locks via coherence
 Load locked synchronization
 Load memory data LMD simple MIPS implementation
 Load stalls MIPS R4000 pipeline
 Load store unit Fermi GPU
 Load upper immediate LUI MIPS operations
 Load-store instruction set architecture basic concept
 Local address space segmented virtual memory
 Local area networks LANs characteristics
 Local miss rate definition
 Local node directory-based cache coherence protocol basics
 Local optimizations compilers
 Local predictors tournament predictors
 Local scheduling ILP VLIW processor
 Locality see Principle of locality Local Memory centralized shared-memory architectures
 Lock-up free cache
 Locks via coherence
 Logical units
 Logical volumes
 Long displacement addressing VAX
 Long integer operand sizes types
 Long-haul networks see Wide area networks WANs Long Instruction Word LIW EPIC
 Loop exit predictor Intel Core i7
 Loop interchange compiler optimizations
 Loop stream detection Intel Core i7 micro-op buffer
 Loop unrolling basic considerations
 Loop-carried dependences CUDA
 Loop-level parallelism definition
 Lossless networks definition
 Lossy networks definition
 M M
 M-bus see Memory bus M-bus McCreight Ed
 M32R
 M32R instructions
 M32R-unique
 M32R-unique instructions
 MAC see Multiply-accumulate MAC Machine language programmer
 MAX multimedia support
 MCF compiler optimizations
 MCP operating system
 MESI see Modified-Exclusive- Shared-Invalid MESI protocol Message ID packet header
 MESIF protocol
 MFLOPS see Millions of floating-point operations per second MFLOPS Microarchitecture as architecture component
 MIMD
 MIMD Multiple Instruction Streams Multiple Data Streams and Amdahl s law
 MIMD vs GPU
 MIMDs
 MIN vs direct network costs
 MINs see Multistage interconnection networks MINs MIPS Microprocessor without Interlocked Pipeline Stages addressing modes
 MINs vs direct networks
 MIP FP unit
 MIPS
 MIPS FP operations
 MIPS FP operations basic considerations
 MIPS FP performance
 MIPS FP pipeline
 MIPS FP pipeline performance
 MIPS ISA
 MIPS M2000
 MIPS M2000 vs V AX
 MIPS M2000 vs VAX
 MIPS MDMX characteristics
 MIPS R10000
 MIPS R100000 sequential consistency
 MIPS R2000
 MIPS R3000 integer arithmetic
 MIPS R3010 arithmetic functions
 MIPS R4000
 MIPS R4000 FP pipeline
 MIPS R4000 early pipelined CPUs
 MIPS R4000 performance
 MIPS R4000 pipeline
 MIPS R8000 precise exceptions
 MIPS VMIPS calculations
 MIPS VMIPS for DAXPY loop
 MIPS addressing modes
 MIPS addressing modes for data transfer
 MIPS conditional branches
 MIPS control
 MIPS control flow instructions
 MIPS core
 MIPS core common extensions
 MIPS core compare and conditional branch
 MIPS core extensions
 MIPS data transfers
 MIPS data types
 MIPS dynamic instruction mix
 MIPS dynamic instructions
 MIPS exceptions
 MIPS extension
 MIPS floating-point operations
 MIPS implementation
 MIPS instruction format
 MIPS multicycle operations basic considerations
 MIPS nonaligned data transfers
 MIPS operations
 MIPS pipeline
 MIPS pipeline FP operations
 MIPS pipeline control
 MIPS pipeline multicycle operations
 MIPS precise exceptions
 MIPS registers
 MIPS scoreboarding
 MIPS structure
 MIPS unaligned reads
 MIPS unaligned word reads
 MIPS vs VMIPS
 MIPS with scoreboard
 MIPS16 addressing modes
 MIPS16-unique
 MIPS16-unique instructions
 MIPS2000 instruction benchmarks
 MIPS32 vs VAX sort
 MIPS64
 MIPS64 ISA
 MIPS64 ISA formats
 MIPS64 addressing modes
 MIPS64 architecture
 MIPS64 instruction subset
 MIPS64 instructions
 MIPS64-unique instructions
 MISD see Multiple Instruction Streams Single Data Stream Misprediction rate branch-prediction buffers
 MIT Raw characteristics
 MIU see Mesh interface unit MIU Mixed cache AMD Opteron example
 MMX
 MMX multimedia support
 MMX see Multimedia Extensions MMX Mobile clients data usage
 MOESI protocol
 MOESI see Modified-Owned- Exclusive-Shared-Invali d MOESI protocol Moore s law DRAM
 MPEG Multimedia SIMD Extensions history
 MPI see Message Passing Interface MPI MPPs see Massively parallel processors MPPs MSP see Multi-Streaming Processor MSP MTBF see Mean time between failures MTBF MTDL see Mean time until data loss MTDL MTTF see Mean time to failure MTTF MTTR see Mean time to repair MTTR Multibanked caches cache optimization
 MSP module
 MTTF
 MTTF calculation
 MVAPICH
 MVL
 MVL see Maximum vector length MVL MXP processor components
 Machine memory Virtual Machines
 Macro-op fusion Intel Core i7
 Magnetic storage access time
 Mail servers benchmarking
 Main Memory addressing modes
 Manufacturing cost chip fabrication case study
 MapReduce
 MapReduce calculations
 MapReduce cloud computing
 MapReduce cost calculations
 MapReduce cost on EC2
 Mark-I
 Mark-II
 Mark-III
 Mark-IV
 MasPar
 Mask Registers basic operation
 Massively parallel processors MPPs characteristics
 Matrix multiplication benchmarks
 Matrix300 kernel definition
 Mauchly John
 Maximum transfer unit network interfaces
 Maximum vector length MVL Multimedia SIMD extensions
 Mean time between failures MTBF fallacies
 Mean time to failure MTTF computer system power consumption case study
 Mean time to repair MTTR dependability benchmarks
 Mean time until data loss MTDL RAID reconstruction
 Media extensions DSPs
 Media interconnection networks
 Mellanox MHEA28-XT
 Memory Interface Unit NVIDIA GPU ISA
 Memory access ARM Cortex-A8 example
 Memory addressing ALU immediate operands
 Memory banks see also Banked memory gather-scatter
 Memory bus M-bus definition
 Memory consistency basic considerations
 Memory hierarchy address space
 Memory hierarchy design access times
 Memory mapping memory hierarchy
 Memory protection control dependence
 Memory stall cycles average memory access time
 Memory system cache optimization
 Memory technology basics DRAM
 Memory-constrained scaling scientific applications on parallel processors
 Memory-memory instruction set architecture ISA classification
 Memoryless definition
 Mesh interface unit MIU Intel SCCC
 Mesh network characteristics
 Mesh topology characteristics
 Message Passing Interface MPI function
 Message-passing communication historical background
 Messages multithreading
 Micro-ops Intel Core i7
 Microbenchmarks disk array deconstruction
 Microfusion Intel Core i7 micro-op buffer
 Microinstructions complications
 Microprocessor overview clock rate trends
 Microprocessor without Interlocked Pipeline Stages see MIPS Microprocessor without Interlocked Pipeline Stages Microsoft cloud computing
 Microsoft Azure
 Microsoft DirectX
 Microsoft Windows
 Microsoft Windows benchmarks
 Microsoft XBox
 Microsystems SP ARC V8 floating-point precisions
 Microsystems SP ARC VIS Sun characteristics
 Microsystems SP ARCstation-20
 Migration cache coherent multiprocessors
 Millions of floating-point operations per second MFLOPS early performance measures
 Minicomputers replacement by microprocessors
 Minniespec benchmarks ARM Cortex-A8
 Misalignment memory address interpretation
 Mispredictions ARM Cortex-A8
 Miss penalty average memory access time
 Miss rate AMD Opteron data cache
 Misses per instruction application OS statistics
 Mitsubishi M32R addressing modes
 Mixer radio receiver
 Miya Eugene
 Modified state coherence protocol
 Modified-Exclusive-Shared-Invalid MESI protocol characteristics
 Modified-Owned-Exclusive-Shared-In valid MOESI protocol characteristics
 Modula-3 integer division remainder
 Module availability definition
 Module reliability definition
 Mortar shot graphs multiprocessor performance measurement
 Motion JPEG encoder Sanyo VPC-SX500 digital camera
 Motorola
 Move address V AX
 Multi-Streaming Processor MSP Cray X1
 Multichip modules OCNs
 Multicomputers cluster history
 Multicore processors architecture goals requirements
 Multics protection software
 Multicycle operations MIPS pipeline basic considerations
 Multidimensional arrays dependences
 Multiflow processor
 Multigrid methods Ocean application
 Multilevel caches cache optimizations
 Multilevel exclusion definition
 Multilevel inclusion definition
 Multimedia Extensions MMX compiler support
 Multimedia SIMD
 Multimedia SIMD Extensions
 Multimedia SIMD Extensions basic considerations
 Multimedia SIMD Extensions history
 Multimedia SIMD GPU comparisons
 Multimedia SIMD architectures
 Multimedia SIMD comparison
 Multimedia SIMD vs GPU
 Multimedia SIMD vs GPUs
 Multimedia applications desktop processor support
 Multimedia instructions ARM Cortex-A8
 Multimedia user interfaces PMDs
 Multimode fiber interconnection networks
 Multipass array multiplier example
 Multiple Instruction Streams Multiple Data Streams see MIMD Multiple Instruction Streams Multiple Data Streams Multiple Instruction Streams Single Data Stream MISD definition
 Multiple lanes technique vector instruction set
 Multiple paths ILP limitation studies
 Multiple-issue processors basic VLIW approach
 Multiple-precision addition
 Multiply operations chip comparison
 Multiply-accumulate MAC DSP
 Multiprocessor basics architectural issues and approaches
 Multiprocessor history bus-based coherent multiprocessors
 Multiprogramming definition
 Multistage interconnection networks MINs bidirectional
 Multistage switch fabrics topology
 Multithreaded SIMD Processor
 Multithreaded SIMD Processor block diagram
 Multithreaded SIMD processor
 Multithreaded vector processor definition
 Multithreading coarse-grained
 Myrinet SAN
 N NAK see Negative acknowledge NAK Name dependences ILP
 N-body algorithms Barnes application
 N-cube topology characteristics
 N-way set associative block placement
 NAND Flash definition
 NAS see Network attached storage NAS NAS Parallel Benchmarks InfiniBand
 NBS DYSEAC
 NEC Earth Simulator peak performance
 NEC SX
 NEC SX-8
 NEC SX-9 first vector computers
 NEC VR
 NEWS communication
 NEWS communication see North-East-West-South communication Newton s iteration
 NFS benchmarking
 NFS see Network File System NFS NIC see Network interface card NIC Nicely Thomas
 NIC vs I O subsystems
 NMOS DRAM
 NOW project
 NSFNET
 NTSC PAL encoder Sanyo VPC-SX500 digital camera
 NUMA
 NUMA see Nonuniform memory access NUMA NVIDIA GeForce
 NVIDIA
 NVIDIA CUDA and AMD terminology
 NVIDIA GPU
 NVIDIA GPU ISA
 NVIDIA GPU Memory
 NVIDIA GPU Memory structures
 NVIDIA GPU computational structures
 NVIDIA GPU programming
 NVIDIA computational structures
 NVIDIA parallelism
 NVIDIA programmers
 NVIDIA systems fine-grained multithreading
 NVIDIA terminology
 NYU Ultracomputer
 NaN
 NaN Not a Number
 Nameplate power rating WSCs
 National Science Foundation WAN history
 Natural parallelism embedded systems
 Negative acknowledge NAK cache coherence
 Negative condition code MIPS core
 Negative-first routing
 Nehalem
 Nehalem floorplan
 Nested page tables
 NetApp FAS6000 filer
 NetApp see Network Appliance NetApp Netflix AWS
 Netflix traffic
 Netscape
 Network Appliance NetApp FAS6000 filer
 Network File System NFS benchmarking
 Network attached storage NAS block servers vs filers
 Network bandwidth interconnection network
 Network buffers network interfaces
 Network fabric switched-media networks
 Network injection bandwidth interconnection network
 Network interface card NIC functions
 Network interface fault tolerance
 Network layer definition
 Network nodes direct network topology
 Network of Workstations
 Network on chip NoC characteristics
 Network ports interconnection network topology
 Network protocol layer interconnection networks
 Network reception bandwidth interconnection network
 Network reconfiguration commercial interconnection networks
 Network technology see also Interconnection networks Google WSC
 Network-Based Computer Laboratory Ohio State
 No-write allocate definition
 NoC see Network on chip NoC Nodes coherence maintenance
 Nokia cell phone circuit board
 Nokia circuit board
 Non-unit strides multidimensional arrays in vector architectures
 Nonaligned data transfers MIPS64
 Nonatomic operations cache coherence
 Nonbinding prefetch cache optimization
 Nonblocking caches cache optimization
 Nonblocking crossbar centralized switched networks
 Nonfaulting prefetches cache optimization
 Nonrestoring division
 Nonuniform memory access NUMA DSM as
 North-East-West-South communication network topology calculations
 North-last routing
 Not a Number NaN
 Notifications interconnection networks
 Nullification PA-RISC instructions
 Nullifying branch branch delay slots
 O Observed performance fallacies
 OCN characteristics
 OCN example
 OCN history
 OCNs
 OCNs see On-chip networks OCNs Offline reconstruction RAID
 OCNs vs SANs
 OLTP see On-Line Transaction Processing OLTP Omega example
 OLTP workload
 OMNETPP Intel Core i7
 OS and page size
 OS determination
 OS-scheduled disk access
 OSI model layers
 OSI see Open Systems Interconnect OSI Out-of-order completion data hazards
 Occupancy communication bandwidth
 Ocean
 Ocean application
 Ocean application characteristics
 Offload engines network interfaces
 Offset addressing modes
 On-Line Transaction Processing OLTP commercial workload
 On-chip cache optimization
 On-chip memory embedded systems
 On-chip networks OCNs basic considerations
 One s complement
 One-way conflict misses definition
 Online reconstruction RAID
 Open Systems Interconnect OSI Ethernet
 Open source software Amazon Web Services
 OpenCL GPU programming
 OpenGL
 Operand addressing mode Intel 80x86
 Operand delivery stage Itanium
 Operands DSP
 Operating systems general address translation
 Operation faults storage systems
 Operational costs basic considerations
 Operational expenditures OPEX WSC costs
 Operator dependability disks
 Opteron
 Opteron L1 L2
 Opteron data TLB
 Opteron data cache
 Opteron data cache example
 Opteron mapping
 Opteron memory
 Opteron memory hierarchy
 Opteron memory management
 Oracle database commercial workload
 Ordering and deadlock
 Organization buffer switch microarchitecture
 Orthogonality compiler writing-architecture relationship
 Out-of-order execution and cache miss
 Out-of-order processors DLP
 Out-of-order write dynamic scheduling
 Output buffered switch HOL blocking
 Output dependence compiler history
 Overclocking microprocessors
 Overflow condition code MIPS core
 Overflow integer arithmetic
 Overhead adaptive routing
 Overlapping triplets historical background
 Oversubscription array switch
 P Packed decimal definition
 PA-RISC instructions
 PA-RISC unique
 PA-RISC-unique
 PARSEC benchmarks Intel Core i7
 PC as
 PC see Program counter PC PCI bus historical background
 PC-relative addressing mode VAX
 PCI-X
 PCIe
 PCIe see PCI-Express PCIe PCI-Express PCIe
 PCMCIA slot Sony PlayStation
 PDP-11
 PDU see Power distribution unit PDU Peak performance Cray X1E
 PID
 PID see Process-identifier PID tags Pin-out bandwidth topology
 PIDs
 PLA early computer arithmetic
 PMD see Personal mobile device PMD Points-to analysis basic approach
 PMDs
 PSUs see Power Supply Units PSUs PTE see Page Table Entry PTE PTX see Parallel Thread Execution PTX PUE see Power utilization effectiveness PUE Python language hardware impact on software development
 PTX
 PTX Instructions
 PTX assembler
 PTX instruction set
 PTX instructions
 PTX vs x86
 PUE
 PUE statistics
 Packet discarding congestion management
 Packet transport interconnection networks
 Packets ATM
 Page Table Entry PTE AMD64 paged virtual memory
 Page coloring definition
 Page faults cache optimization
 Page offset cache optimization
 Page references in bold represent figures and tables Numbers
 Page size cache optimization
 Page tables address translation
 Paged segments characteristics
 Paged virtual memory Opteron example
 Pages
 Paired single operations DSP media extensions
 Palt definition
 Papadopolous Greg
 Parallel Thread Execution PTX Instruction CUDA Thread
 Parallel Thread Execution PTX basic GPU thread instructions
 Parallel processors areas of debate
 Parallel programming computation communication
 Parallelism cache optimization
 Paravirtualization system call performance
 Parity dirty bits
 Partial disk failure dirty bits
 Partial store order relaxed consistency models
 Partitioned add operation DSP media extensions
 Partitioning Multimedia SIMD Extensions
 Pattern disk array deconstruction
 Payload messages
 Peer-to-peer internetworking
 Pegasus
 PennySort competition
 Pentium vs Opteron
 Pentium vs Opteron protection
 Perfect Club benchmarks vector architecture programming
 Perfect processor ILP hardware model
 Perfect-shuffle exchange interconnection network topology
 Performability RAID reconstruction
 Performance see also Peak performance advanced directory protocol case study
 Permanent failure commercial interconnection networks
 Permanent faults storage systems
 Personal computers LANs
 Personal mobile device PMD characteristics
 PetaBox GB2000 Internet Archive Cluster
 Phase-ordering problem compiler structure
 Phits see Physical transfer units phits Physical addresses address translation
 Physical cache definition
 Physical channels
 Physical layer definition
 Physical memory centralized shared-memory multiprocessors
 Physical transfer units phits
 Physical volumes
 Pipe segment definition
 Pipe stage branch prediction
 Pipeline bubble stall as
 Pipeline cycles per instruction basic equation
 Pipeline delays ARM Cortex-A8
 Pipeline interlock data dependences
 Pipeline organization dependences
 Pipeline registers branch hazard stall
 Pipeline scheduling basic considerations
 Pipeline stall cycles branch scheme performance
 Pipelined CPUs early versions
 Pipelined circuit switching
 Pipelining branch cost reduction
 Point-to-point links bus replacement
 Point-to-point multiprocessor example
 Point-to-point networks directory-based coherence
 Poison bits compiler-based speculation
 Poisson Sime on
 Poisson distribution basic equation
 Polycyclic scheduling
 Port number network interfaces
 Portable computers interconnection networks
 Position independence control flow instruction addressing modes
 Power Supply Units PSUs efficiency ratings
 Power consumption see also Energy efficiency cache optimization
 Power distribution for servers
 Power distribution unit PDU WSC infrastructure
 Power failure exceptions
 Power gating transistors
 Power modes WSCs
 Power utilization effectiveness PUE datacenter comparison
 Power-performance low-power servers
 PowerPC
 PowerPC ActiveC characteristics
 PowerPC AltiVec multimedia support
 PowerPC addressing modes
 PowerPC instructions
 PowerPC-unique
 PowerPC-unique instructions
 Precise exceptions definition
 Precisions floating-point arithmetic
 Predicate Registers definition
 Predicated instructions exposing parallelism
 Predication TI TMS320C6x DSP
 Predicted-not-taken scheme branch penalty reduction
 Predictions see also Mispredictions address aliasing
 Prefetching integrated instruction fetch units
 Prefix Intel 80x86 integer operations
 Present bit IA-32 descriptor table
 Presentation layer definition
 Price vs cost
 Price-performance ratio cost trends
 Principle of locality bidirectional MINs
 Private Memory definition
 Private data cache protocols
 Private variables NVIDIA GPU Memory
 Pro
 Procedure calls compiler structure
 Process IDs Virtual Machines
 Process concept definition
 Process switch definition
 Process-identifier PID tags cache addressing
 Processor consistency latency hiding with speculation
 Processor cycles cache performance
 Processor performance and average memory access time
 Processor performance equation computer design principles
 Processor speed and clock rate
 Processor-dependent optimizations compilers
 Processor-intensive benchmarks desktop performance
 Producer-server model response time and throughput
 Productivity CUDA
 Profile-based predictor misprediction rate
 Program counter PC addressing modes
 Program counter-relative addressing control flow instructions
 Program order cache coherence
 Programming models CUDA
 Programming primitive CUDA Thread
 Protection schemes control dependence
 Protocol deadlock routing
 Protocol stack example
 Pseudo-least recently used LRU block replacement
 Q QCDOD
 QoS see Quality of service QoS QsNetII
 QsNetII
 Quadrics SAN
 Quality of service QoS WAN history
 Quantitative performance measures development
 Queue definition
 Queue discipline definition
 Queuing locks large-scale multiprocessor synchronization
 Queuing theory basic assumptions
 Quickpath Intel Xeon cache coherence
 R Race-to-halt definition
 R-R instructions
 R10000
 R4000
 R4000 performance
 R4000 pipeline
 R4000 pipeline structure
 RAID
 RAID Redundant array of inexpensive disks data replication
 RAID benchmarks
 RAID history
 RAID levels
 RAID performance prediction
 RAID reconstruction
 RAID reconstruction case study
 RAID row-diagonal parity
 RAID storage servers
 RAID systems
 RAM random access memory switch microarchitecture
 RAMAC-350 Random Access Method of Accounting Control
 RAR see Read after read RAR RAS see Row access strobe RAS RAW see Read after write RAW Ray casting RC GPU comparisons
 RAW
 RECN see Regional explicit congestion notification RECN Reconfiguration deadlock routing
 RF see Register fetch RF Rings characteristics
 RISC
 RISC Reduced Instruction Set Computer addressing modes
 RISC architecture
 RISC architectures
 RISC classic pipeline
 RISC code size
 RISC development
 RISC history
 RISC instruction set
 RISC instruction set lineage
 RISC instructions
 RISC processor
 RISC systems addressing modes
 RISC systems addressing modes and instruction formats
 RISC-I
 RISC-II
 RISCs
 RISCs desktop systems
 RLP see Request-level parallelism RLP ROB see Reorder buffer ROB Roofline model GPU performance
 ROB
 ROB commit
 ROB instruction
 ROB instructions
 RR see Round-robin RR RS format instructions IBM
 RS and SI format instructions
 RX format instructions
 RX format instructions IBM
 Rack units U WSC architecture
 Radio frequency amplifier radio receiver
 Radio receiver components
 Radio waves wireless networks
 Radix-2
 Radix-2 multiplication division
 Radix-4 multiplication division
 Radix-8 multiplication
 Random Access Method of Accounting Control
 Random replacement cache misses
 Random variables distribution
 Read after write RAW data hazards
 Read miss AMD Opteron data cache
 Read operands stage ID pipe stage
 Real memory Virtual Machines
 Real-time constraints definition
 Real-time performance PMDs
 Real-time performance requirement definition
 Real-time processing embedded systems
 Realizable processors ILP limitations
 Rearrangeably nonblocking centralized switched networks
 Receiving overhead communication latency
 Reconstruction RAID
 Recovery time vector processor
 Recurrences basic approach
 Red-black Gauss-Seidel Ocean application
 Reduced Instruction Set Computer see RISC Reduced Instruction Set Computer Reductions commercial workloads
 Redundancy Amdahl s law
 Redundant array of inexpensive disks see RAID Redundant array of inexpensive disks Redundant multiplication integers
 Redundant power supplies example calculations
 Reference bit memory hierarchy
 Regional explicit congestion notification RECN congestion management
 Register addressing mode MIPS
 Register allocation compilers
 Register deferred addressing VAX
 Register definition
 Register fetch RF MIPS data path
 Register file data hazards
 Register indirect addressing mode Intel 80x86
 Register management software-pipelined loops
 Register prefetch cache optimization
 Register renaming dynamic scheduling
 Register result status MIPS scoreboard
 Register stack engine IA-64
 Register tag example
 Register windows SPARC instructions
 Register-memory instruction set architecture architect-compiler writer relationship
 Registers DSP examples
 Regularity bidirectional MINs
 Relative speedup multiprocessor performance
 Relaxed consistency models basic considerations
 Release consistency relaxed consistency models
 Reliability Amdahl s law calculations
 Relocation virtual memory
 Remainder floating point
 Remington-Rand
 Remote direct memory access RDMA InfiniBand
 Remote node directory-based cache coherence protocol basics
 Reorder buffer ROB compiler-based speculation
 Repeat interval MIPS pipeline FP operations
 Replication cache coherent multiprocessors
 Reply messages
 Reproducibility performance results reporting
 Request messages
 Request phase arbitration
 Request-level parallelism RLP basic characteristics
 Request-reply deadlock routing
 Requested protection level segmented virtual memory
 Reservation stations dependent instructions
 Resource allocation computer design principles
 Resource sparing commercial interconnection networks
 Responsiveness PMDs
 Restartable pipeline definition
 Restorations SLA states
 Restoring division
 Resume events control dependences
 Return address predictors instruction fetch bandwidth
 Returns Amdahl s law
 Reverse path cell phones
 Ripple-carry adder
 Ripple-carry addition
 Roofline model
 Roofline visual performance model
 Round digit
 Round-robin RR arbitration
 Rounding modes
 Routers BARRNet
 Routing algorithm commercial interconnection networks
 Row access strobe RAS DRAM
 Row major order blocking
 Row-diagonal parity example
 Ruby on Rails hardware impact on software development
 S S3 see Amazon Simple Storage Service S3 SaaS see Software as a Service SaaS Sandy Bridge dies wafter example
 SAN characteristics
 SAN example
 SANs
 SANs see System storage area networks SANs Sanyo digital cameras SOC
 SAS see Serial Attach SCSI SAS drive SASI
 SATA Serial Advanced Technology Attachment disks Google WSC servers
 SAXPY GPU raw relative Index
 SCCC see Intel Single-Chip Cloud Computing SCCC Schorr Herb
 SCSI Small Computer System Interface Berkeley s T ertiary Disk project
 SCSI history
 SDRAM power consumption
 SDRAM see Synchronous dynamic random-access memory SDRAM SDRWAVE
 SDRAM timing diagram
 SDRAMs
 SFF see Small form factor SFF disk SFS benchmark NFS
 SGI see Silicon Graphics systems SGI
 SIMD
 SIMD Extensions
 SIMD Instruction CUDA Thread
 SIMD Instructions
 SIMD Lane Registers
 SIMD Lane Registers definition
 SIMD Lanes
 SIMD Lanes definition
 SIMD Multimedia Extensions
 SIMD Processor
 SIMD Processors
 SIMD Processors see also Multithreaded SIMD Processor block diagram
 SIMD Single Instruction Stream Multiple Data Stream definition
 SIMD Thread GPU conditional branching
 SIMD Thread Scheduler
 SIMD Thread Scheduler definition
 SIMD computer history
 SIMD computers
 SIMD development
 SIMD exploitation
 SIMD extensions
 SIMD history
 SIMD instructions
 SIMD multimedia instructions
 SIMD processor
 SIMD supercomputer development
 SIMD thread scheduler
 SIMD thread scheduling
 SIMT Single Instruction Multiple Thread GPU programming
 SISD
 SISD Single Instruction Stream Single Data Stream
 SLA states
 SLAs see Service level agreements SLAs SLI see Scan Line Interleave SLI SLOs see Service level objectives SLOs SLQ see Serve-longest-queue SLQ scheme SLT see Set-on-less-than instructions SLT SM see Distributed shared memory DSM Small Computer System Interface see SCSI Small Computer System Interface Small form factor SFF disk
 SMP
 SMP DSM definition
 SMP DSM shared memory
 SMP and snooping limitations
 SMP limitations
 SMP see Symmetric multiprocessors SMP
 SMT
 SMT and ST performance
 SMT on superscalar processors
 SMT see Simultaneous multithreading SMT Sun T1 effectiveness
 SNR see Signal-to-noise ratio SNR SoC see System-on-chip SoC Soft errors definition
 SPARC
 SPARC instructions
 SPARC-unique
 SPARC-unique instructions
 SPARCLE processor
 SPEC Java Business Benchmark JBB multicore processor performance
 SPEC benchmarks
 SPEC benchmarks branch predictor correlation
 SPEC server benchmarks
 SPEC-optimized processors vs density-optimized
 SPEC2000 benchmarks ARM Cortex-A8 memory
 SPEC2006 benchmarks evolution
 SPEC89 benchmarks branch-prediction buffers
 SPEC92 benchmarks hardware vs software speculation
 SPEC95 benchmarks return address predictors
 SPECCPU2000 benchmarks displacement addressing mode
 SPECCPU2006 benchmarks
 SPECCPU2006 benchmarks branch predictors
 SPECINT benchmarks hardware prefetching
 SPECINT2000 benchmarks MIPS dynamic instruction mix
 SPECINT2006 benchmarks Intel processor clock rates
 SPECInt92 benchmarks Intel 80x86 vs DLX
 SPECJVM98 SPECMail benchmark characteristics
 SPECPower benchmarks
 SPECPower benchmarks Google server benchmarks
 SPECRate benchmarks Intel Core i7
 SPECRate2000 benchmarks SMT
 SPECRatios execution time examples
 SPECSFS benchmarks example
 SPECWeb benchmarks characteristics
 SPECWeb99 benchmarks multiprocessing multithreading-based performance
 SPECfp benchmarks hardware prefetching
 SPECfp2000 benchmarks hardware prefetching
 SPECfp2000 execution times
 SPECfp2006 benchmarks Intel processor clock rates
 SPECfp92 benchmarks Intel 80x86 vs DLX
 SPECfpRate benchmarks multicore processor performance
 SPEChpc96 benchmark vector processor history
 SPECint95 benchmarks interconnection networks
 SPECintRate benchmark multicore processor performance
 SPECjbb
 SPECpower
 SPECpower benchmark
 SPECvirt Sc2010 benchmarks server
 SPLASH parallel benchmarks SMT on superscalar processors
 SPRAM Sony PlayStation
 SRAM
 SRAM see Static random-access memory SRAM SRT division chip comparison
 SRT division
 SS format instructions
 SSDs see Solid-state disks SSDs SSE see Intel Streaming SIMD Extension SSE SS format instructions IBM
 SVM see Secure Virtual Machine SVM Swap procedure V AX code example
 SaaS
 Sanyo VPC-SX500 digital camera
 Sanyo VPC-SX500 digital camera case study
 Sanyo VPC-SX500 digital camera embedded system case study
 Sanyo digital camera SOC
 Sanyo digital cameras
 Saturating arithmetic DSP media extensions
 Saturating operations definition
 Scalability
 Scalable GPUs historical background
 Scalar Processors see also Superscalar processors definition
 Scalar expansion loop-level parallelism dependences
 Scalar registers Cray X1
 Scaled addressing V AX
 Scaled speedup Amdahl s law and parallel computers
 Scaling Amdahl s law and parallel computers
 Scan Line Interleave SLI scalable GPUs
 Scientific applications Barnes
 Scoreboarding ARM Cortex-A8
 Second-level caches see also L2 caches ARM Cortex-A8
 Secure Virtual Machine SVM
 Seek distance storage disks
 Seek time storage disks
 Segment basics Intel 80x86
 Segment descriptor IA-32 processor
 Segmented virtual memory bounds checking
 Self-correction Newton s algorithm
 Self-draining pipelines
 Self-routing MINs
 Semantic clash high-level instruction set
 Semantic gap high-level instruction set
 Semiconductors DRAM technology
 Sending overhead communication latency
 Sense-reversing barrier code example
 Sequence of SIMD Lane Operations
 Sequence of SIMD Lane Operations definition
 Sequency number packet header
 Sequent Symmetry
 Sequential consistency latency hiding with speculation
 Sequential interleaving multibanked caches
 Serial Advanced Technology Attachment disks see SATA Serial Advanced Technology Attachment disks Serial Attach SCSI SAS drive historical background
 Serialization barrier synchronization
 Serpentine recording
 Serve-longest-queue SLQ scheme arbitration
 Server real-world considerations
 Server side Java operations per second ssj ops example calculations
 Server utilization calculation
 ServerNet interconnection network fault tolerance
 Servers see also Warehouse-scale computers WSCs as computer class
 Service Health Dashboard A WS Service interruption SLAs
 Service accomplishment SLAs
 Service level agreements SLAs Amazon Web Services
 Service level objectives SLOs and dependability
 Session layer definition
 Set associativity
 Set basics block replacement
 Set-on-less-than instructions SLT MIPS16
 Settle time
 Shadow page table Virtual Machines
 Sharding WSC memory hierarchy
 Shared Memory definition
 Shared state cache block
 Shared-media networks effective bandwidth vs nodes
 Shared-memory communication large-scale multiprocessors
 Shared-memory multiprocessors basic considerations
 Shared-memory synchronization MIPS core extensions
 Sharing addition segmented virtual memory
 Shear algorithm
 Shear algorithms disk array deconstruction
 Shifting over zeros integer multiplication division
 Short-circuiting see Forwarding SI format instructions IBM
 Sign magnitude
 Sign-extended offset RISC
 Signal-to-noise ratio SNR wireless networks
 Signals definition
 Signed number arithmetic
 Signed-digit representation example
 Significand
 Silicon Graphics 4D
 Silicon Graphics Altix
 Silicon Graphics Challenge
 Silicon Graphics Origin
 Silicon Graphics systems SGI economies of scale
 Simultaneous multithreading SMT characteristics
 Single Instruction Multiple Thread see SIMT Single Instruction Multiple Thread Single Instruction Stream Multiple Data Stream see SIMD Single Instruction Stream Multiple Data Stream Single Instruction Stream Single Data Stream see SISD Single Instruction Stream Single Data Stream Single-level cache hierarchy miss rates vs cache size
 Single-Streaming Processor SSP Cray X1
 Single-extended precision floating-point arithmetic
 Single-precision floating point arithmetic
 Single-thread ST performance IBM eServer p5
 Skippy algorithm disk deconstruction
 Smalltalk
 Smalltalk SP ARC instructions
 Smart interface cards vs smart SMT see Simultaneous multithreading SMT Snooping cache coherence basic considerations
 Smart switches vs smart interface cards
 Smartphones mobile vs server GPUs
 Soft real-time definition
 Software as a Service SaaS clusters WSCs
 Software development multiprocessor architecture issues
 Software pipelining example calculations
 Software prefetching cache optimization
 Software speculation definition
 Software technology ILP approaches
 Solaris RAID benchmarks
 Solid-state disks SSDs processor performance price power
 Sonic Smart Interconnect OCNs
 Sony PlayStation
 Sony PlayStation Emotion Engine
 Sort primitive GPU vs MIMD
 Sort procedure VAX bubble sort
 Sorting case study
 Source routing basic concept
 Sparse matrices loop-level parallelism dependences
 Spatial locality coining of term
 Special values floating point
 Special-purpose machines historical background
 Special-purpose register compiler writing-architecture relationship
 Speculation see also Hardware-based speculation Software speculation advantages disadvantages
 Speedup Index
 Sperry-Rand
 Split GPU vs MIMD
 Sprowl Bob
 Squared coefficient of variance
 Stack frame VAX
 Stack or Thread Local Storage definition
 Stack pointer VAX
 Stale copy cache coherency
 Stall cycles advanced directory protocol case study
 Stalls AMD Opteron data cache
 Standardization commercial interconnection networks
 Stardent-1500 Livermore Fortran kernels
 Start-up overhead vs peak Start-up time DAXPY on VMIPS
 State transition diagram director vs cache
 Static power basic equation
 Static random-access memory SRAM characteristics
 Static scheduling definition
 Statically based exploitation ILP
 Sticky bit
 Stop Go see Xon Xoff Storage area networks dependability benchmarks
 Storage systems asynchronous I O and OSes
 Store conditional locks via coherence
 Store instructions see also Load-store instruction set architecture definition
 Store-and-forward packet switching
 Streaming Multiprocessor definition
 Strecker William
 Strided accesses Multimedia SIMD Extensions
 Strided addressing see also Unit stride addressing multimedia instruction compiler support
 Strides gather-scatter
 String operations Intel 80x86
 Strip mining DAXPY on VMIPS
 Strip-Mined Vector Loop convoys
 Stripe disk array deconstruction
 Striping disk arrays
 Strong scaling Amdahl s law and parallel computers
 Structural hazards basic considerations
 Structural stalls MIPS R4000 pipeline
 Subset property and inclusion
 Summary overflow condition code PowerPC
 Sun Microsystems Enterprise
 Sun Microsystems Niagara T1 T2 processors characteristics
 Sun Microsystems SPARC addressing modes
 Sun Microsystems SPARCCenter
 Sun Microsystems SPARCstation-2 Sun Sun
 Sun Microsystems Ultra
 Sun Microsystems UltraSP ARC
 Sun Microsystems UltraSPARC T1 processor characteristics
 Sun Microsystems cache optimization
 Sun Modular Datacenter
 Sun T1 effectiveness
 Sun T1 fine-grained multithreading effectiveness
 Sun T1 multithreading
 Sun T1 multithreading unicore
 Sun T1 multithreading unicore Spin locks via coherence
 Sun T1 multithreading unicore performance
 Sun T1 processor
 Sun Ultra
 SuperH-unique
 SuperH-unique instructions
 Superblock scheduling basic process
 Supercomputers commercial interconnection networks
 Superlinear performance multiprocessors
 Superpipelining definition
 Superscalar processors coining of term
 Superscalar registers sample renaming code
 Supervisor process virtual memory protection
 Sussenguth Ed
 Sutherland Ivan
 Swim data cache misses
 Switch fabric switched-media networks
 Switch microarchitecture basic microarchitecture
 Switch ports centralized switched networks
 Switch statements control flow instruction addressing modes
 Switched networks centralized
 Switched-media networks basic characteristics
 Switches array WSCs
 Switching commercial interconnection networks
 Syllable IA-64
 Symbolic loop unrolling software pipelining
 Symmetric multiprocessors SMP characteristics
 Symmetric shared-memory multiprocessors see also Centralized shared-memory multiprocessors data caching
 Synapse N
 Synchronization AltaVista search
 Synchronous I O definition
 Synchronous dynamic random-access memory SDRAM ARM Cortex-A8
 Synchronous event exception requirements
 Synonyms address translation
 Synthetic benchmarks definition
 System Performance and Evaluation Cooperative SPEC see SPEC benchmarks System Processor definition
 System Virtual Machines definition
 System area networks historical overview
 System calls CUDA Thread
 System interface controller SIF Intel SCCC
 System response time transactions
 System storage area networks SANs characteristics
 System-on-chip SoC cell phone
 Systems on a chip SOC cost trends
 T Tag AMD Opteron data cache
 T omasulo s algorithm
 T1 multithreading unicore performance
 TB see Translation buffer TB TB-80 VME rack example
 TB-80 IOPS
 TB-80 VME rack
 TB-80 cluster
 TB-80 cluster MTTF
 TC see Tag check TC TCAs see Target channel adapters TCAs
 TCO case study
 TCP IP
 TCP IP headers
 TCP IP reliance
 TDP
 TERA processor
 TFLOPS parallel processing debates
 TFT see Thin-film transistor TFT Thacker Chuck
 TI 320C55 DSP
 TI 320C6x DSP
 TI TMS320C55
 TI TMS320C55 DSP
 TI TMS320C55 DSP architecture
 TI TMS320C64x
 TI TMS320C6x
 TI TMS320C6x DSP
 TI TMS320C6x DSP architecture
 TI TMS320C6x instruction packet
 TLB
 TLB during address translation
 TLB interaction
 TLB see Translation lookaside buffer TLB TLP see Task-level parallelism TLP Thread-level parallelism TLP Tomasulo s algorithm advantages
 TLB see Translation lookaside buffer TLB translation buffer
 TLB structure
 TLBs
 TLP
 TLP basic considerations
 TLP programmer s viewpoint
 TLP see Thread-level parallelism TLP trace scheduling
 TLP workloads
 TMS320C55 DSP
 TOP500
 TOS see Top Of Stack TOS register Total Cost of Ownership TCO WSC case study
 TP benchmarks
 TP see Transaction-processing TP TPC see Transaction Processing Council TPC Trace compaction basic process
 TPC-B shared-memory workloads
 TPC-C file system benchmarking
 TPC-D shared-memory workloads
 TPC-E shared-memory workloads
 TRIPS Edge processor
 TSMC Stratton
 TSS operating system
 TX-2
 Tag check TC MIPS R4000
 Tag fields block identification
 Tail duplication superblock scheduling
 Tailgating definition
 Tandem Computers
 Tandem Computers cluster history
 Target address branch hazards
 Target channel adapters TCAs switch vs NIC
 Target instructions branch delay slot scheduling
 Task-level parallelism TLP definition
 Tegra
 Teleconferencing multimedia support
 Temporal locality blocking
 Terminate events exceptions
 Tertiary Disk
 Tertiary Disk project failure statistics
 Test-and-set operation synchronization
 Texas Instruments
 Texas Instruments ASC first vector computers
 Thermal design power TDP power trends
 Thin-film transistor TFT Sanyo VPC-SX500 digital camera
 Think time transactions
 Thinking Machines
 Thinking Multiprocessors CM-5
 Third-level caches see also L3 caches ILP
 Thrash memory hierarchy
 Thread Block
 Thread Block CUDA Threads
 Thread Block Scheduler
 Thread Block Scheduler definition
 Thread Block comparison
 Thread Block mapping
 Thread Blocks
 Thread Processor Registers definition
 Thread Processor definition
 Thread Scheduler in a Multithreaded CPU definition
 Thread of SIMD Instructions
 Thread of SIMD Instructions characteristics
 Thread of Vector Instructions
 Thread of Vector Instructions definition
 Thread-level parallelism TLP advanced directory protocol case study
 Three-dimensional space direct networks
 Three-level cache hierarchy commercial workloads
 Throttling packets
 Throughput see also Bandwidth definition
 Thumb-unique
 Thumb-unique instructions
 Ticks cache coherence
 Tilera TILE-Gx processors OCNs
 Time division multiple access TDMA cell phones
 Time of flight communication latency
 Time-cost relationship components
 Timing independent
 Tomasulo s advantages
 Tomasulo s algorithm
 Tomasulo s algorithm loop-based example
 Tomasulo s approach
 Tomasulo s scheme
 Top Of Stack TOS register ISA definition
 Topology Index
 Torus networks characteristics
 Total store ordering relaxed consistency models
 Tournament predictors early schemes
 Toy programs performance benchmarks
 Trace scheduling basic approach
 Trace selection definition
 Tradebeans benchmark SMT on superscalar processors
 Traffic intensity queuing theory
 Transaction Processing Council TPC benchmarks overview
 Transaction components
 Transaction-processing TP server benchmarks
 Transfers see also Data transfers as early control flow instruction definition
 Transforms DSP
 Transient failure commercial interconnection networks
 Transient faults storage systems
 Transistors clock rate considerations
 Translation buffer TB virtual memory block identification
 Translation lookaside buffer TLB address translation
 Transmission speed interconnection network performance
 Transmission time communication latency
 Transport latency time of flight
 Transport layer definition
 Transputer
 Tree height reduction definition
 Tree-based barrier large-scale multiprocessor synchronization
 Trees MINs with nonblocking
 Trellis codes definition
 Trojan horses definition
 True dependence finding
 True sharing misses commercial workloads
 True speedup multiprocessor performance
 Turbo mode hardware enhancements
 Turing Alan
 Turn Model routing algorithm example calculations
 Two s complement
 Two-level branch predictors branch costs
 Two-level cache hierarchy cache optimization
 Two-way conflict misses definition Transmission Transmission Control Protocol TCP congestion management
 Two-way set associativity ARM Cortex-A8
 Typical program instruction set considerations
 U U see Rack units U Ultrix DECstation
 UMA see Uniform memory access UMA Unbiased exponent
 UNIVAC I
 UNIX systems architecture costs
 UPS see Uninterruptible power supply UPS USB Sony PlayStation
 UTP see Unshielded twisted pair UTP V Valid bit address translation
 Uncached state directory-based cache coherence protocol basics
 Unconditional branches branch folding
 Underflow floating-point arithmetic
 Unicasting shared-media networks
 Unicode character MIPS data types
 Unified cache AMD Opteron example
 Uniform memory access UMA multicore single-chip multiprocessor
 Uninterruptible instruction hardware primitives
 Uninterruptible power supply UPS Google WSC
 Uniprocessors cache protocols
 Unit stride addressing gather-scatter
 Unpacked decimal
 Unshielded twisted pair UTP LAN history
 Up down routing definition
 Use bit address translation
 User maskable events definition
 User nonmaskable events definition
 User-level communication definition
 User-requested events exception requirements
 Utility computing
 Utilization I O system calculations
 V AX instruction encoding
 V AX instructions
 VAPI InfiniBand
 VAX
 VAX as
 VAX design
 VAX instructions
 VAX sort
 VAX swap
 VAX systems
 VAX vs MIPS
 VCs see Virtual channels VCs Vector architectures computer development
 VGA controller
 VI interface
 VLIW
 VLIW model
 VLIW processors
 VLIW sample code
 VLIW see Very Long Instruction Word VLIW VLR see Vector-length register VLR VLSI see Very-large-scale integration VLSI VMCS see Virtual Machine Control State VMCS VME rack example
 VLR
 VLRs
 VMIPS
 VMIPS basic structure
 VMIPS calculations
 VMIPS on DAXPY
 VMIPS on Linpack
 VMIPS peak performance
 VMIPS performance
 VMIPS vector operation
 VMM implementation
 VMM on nonvirtualizable ISA
 VMM see Virtual machine monitor VMM VMs see Virtual Machines VMs Voltage regulator controller VRC Intel SCCC
 VMMs
 VOQs
 VOQs see Virtual output queues VOQs VRC see Voltage regulator controller VRC VRMs see Voltage regulator modules VRMs Wafers example
 Value prediction definition
 Variable length encoding control flow instruction branches
 Variables and compiler technology
 Vector Facility vector processor history
 Vector Functional Unit vector add instruction
 Vector Instruction definition
 Vector Lane Registers
 Vector Lane Registers definition
 Vector Lanes
 Vector Lanes control processor
 Vector Processor caches
 Vector Registers
 Vector Registers definition
 Vector load store unit memory banks
 Vector loops NVIDIA GPU
 Vector-length register VLR basic operation
 Vector-mask control characteristics
 Vector-mask registers basic operation
 Vectorizable Loop characteristics
 Vectorized Loop see also Body of Vectorized Loop definition
 Vectorized code multimedia compiler support
 Vectorizing compilers effectiveness
 Very Long Instruction Word VLIW clock rates
 Very-large-scale integration VLSI early computer arithmetic
 Video Amazon Web Services
 Video games multimedia support
 Virtual Machines
 Virtual Machines ISA support
 Virtual Machines VMs Amazon Web Services
 Virtual Machines and virtual memory and I O
 Virtual Machines impact
 Virtual Machines protection
 Virtual Machines support
 Virtual address address translation
 Virtual address space example
 Virtual caches definition
 Virtual channels VCs
 Virtual cut-through switching
 Virtual functions control flow instructions
 Virtual machine monitor VMM characteristics
 Virtual memory basic considerations
 Virtual methods control flow instructions
 Virtualizable GPUs future technology
 Virtualizable architecture Intel 80x86 issues
 Voltage regulator modules VRMs WSC server energy efficiency
 Volume-cost relationship components
 Von Neumann John
 Von Neumann computer
 Voodoo2
 WAN example
 WAN history
 WANs
 WANs see Wide area networks WANs WAR see Write after read WAR Warehouse-scale computers WSCs Amazon Web Services
 WAW
 WAW WAR hazards
 WAW see Write after write WAW Way prediction cache optimization
 WB see Write-back cycle WB WCET see Worst-case execution time WCET WDM see Wavelength division multiplexing WDM Weak ordering relaxed consistency models
 WCET
 WSC
 WSC Flash memory
 WSC MapReduce and Hadoop
 WSC TCO
 WSC TCO case study
 WSC architecture
 WSC array switch
 WSC basics
 WSC batch processing
 WSC bottleneck
 WSC calculations
 WSC case study
 WSC containers
 WSC cooling systems
 WSC cost-performance
 WSC data transfer
 WSC efficiency
 WSC efficiency measurement
 WSC energy efficiency
 WSC facilities
 WSC goals requirements
 WSC hardware inactivity
 WSC hierarchy
 WSC infrastructure
 WSC measurement
 WSC memory
 WSC memory costs
 WSC memory hierarchy
 WSC memory latency
 WSC network
 WSC network bottleneck
 WSC operational costs
 WSC performance
 WSC power modes
 WSC processor cost-performance
 WSC processors
 WSC resource allocation
 WSC resource allocation case
 WSC resource allocation case study
 WSC running service
 WSC running service availability
 WSC server data transfer
 WSC server energy efficiency
 WSC servers
 WSC services
 WSC storage
 WSC storage software
 WSC vs datacenter costs
 WSC vs datacenters
 WSC workloads
 WSCs
 WSCs see Warehouse-scale computers WSCs X XBox
 WSCs vs datacenters
 WSCs vs servers
 Wafer yield chip costs
 Wait time shared-media networks
 Waiting line definition
 Wall-clock time execution time
 Wallace tree
 Wallace tree example
 Warp
 Warp Scheduler definition
 Wavelength division multiplexing WDM WAN history
 Way selection
 Weak scaling Amdahl s law and parallel computers W
 Web index search shared-memory workloads
 Web servers benchmarking
 Weighted arithmetic mean time
 Weitek
 West-first routing
 Wet-bulb temperature Google WSC
 Whirlwind project
 Wide area networks WANs ATM
 Wilkes Maurice
 Winchester
 Window latency
 Window size ILP limitations
 Windowing congestion management
 Windows operating systems see Microsoft Windows Wireless networks basic challenges
 Wires energy and power
 Within instruction exceptions definition
 Word count definition
 Word displacement addressing VAX
 Word offset MIPS
 Words aligned misaligned addresses
 Working set effect definition
 Workloads execution time
 Wormhole switching
 Worst-case execution time WCET definition
 Write after read WAR data hazards
 Write after write WAW data hazards
 Write allocate AMD Opteron data cache
 Write broadcast protocol definition
 Write buffer AMD Opteron data cache
 Write hit cache coherence
 Write invalidate protocol directory-based cache coherence protocol example
 Write merging example
 Write miss AMD Opteron data cache
 Write result stage data hazards
 Write serialization hardware primitives
 Write stall definition
 Write strategy memory hierarchy considerations
 Write update protocol definition
 Write-back cache AMD Opteron example
 Write-back cycle WB basic MIPS pipeline
 Write-through cache average memory access time
 XIMD architecture
 Xen VM
 Xen VM example
 Xen VMM see Xen virtual machine Index
 Xen Virtual Machine Amazon Web Services
 Xerox Palo Alto Research Center LAN history
 Xon Xoff interconnection networks
 Y Yahoo WSCs
 Yield chip fabrication
 Z
 Zero condition code MIPS core
 Zero-copy protocols definition
 Zero-load latency Intel SCCC
 Zuse Konrad
 Zynga FarmVille
 adaptive routing
 adaptive routing and fault tolerance
 addition
 address parts
 address space
 address translation
 addressing modes
 addressing modes and instruction formats
 and CPI
 and DLP
 and ECC memory
 and GPU
 and ISA
 and Moore s law
 and OS
 and SMT
 and Tomasulo s algorithm
 and WSCs
 and access time
 and architecture development
 and associativity
 and block size
 and branch penalties
 and cache miss
 and cache size
 and cell phones
 and consistency model
 and dependability
 and dynamic scheduling
 and energy efficiency
 and full associativity
 and memory bandwidth
 and memory hierarchy
 and memory system
 and microprocessor dominance
 and multiple lanes
 and overhead
 and page size
 and parallel computers
 and power
 and processor speed
 and protection
 and relative execution time
 and speculation
 and stall time
 and system characteristics
 and throughput
 and topology
 and unoptimized code
 and virtual channels
 and virtual memory and I O
 antialiasing
 application OS misses
 application trends
 arbitration
 architect-compiler writer relationship
 architecture
 architecture and software development
 architecture costs
 architecture flaws and success
 architecture flaws vs success
 architecture goals requirements
 architecture-specific examples
 areal density
 arithmetic functions
 arithmetic intensity
 arithmetic intensity example
 arithmetic logical
 arithmetic logical instructions
 array switch
 as Content Delivery Network
 as ISA
 as LAN
 as MapReduce inspiration
 as RISC system
 as RISC systems
 as VMIPS basis
 as WAN
 as WSC forerunners
 as black box
 as branch-target buffer variation
 as computer class
 as custom cluster
 as data dependence
 as kernel miss
 as nonblocking
 as operand type
 as performance measurement
 as processor performance predictor
 as program properties
 as recurrence
 as server characteristic
 as utility computing
 average memory access time
 bandwidth vs latency
 barrier synchronization
 basic MIPS pipeline
 basic PTX thread instructions
 basic categories
 basic characteristics
 basic concept
 basic concepts challenges
 basic considerations
 basic equations
 basic function
 basic hardware primitives
 basic hardware types
 basic microarchitecture
 basic optimizations
 basic pipeline
 basic questions
 basic structure
 basic systems
 benchmark information
 benchmarks
 benchmarks ISA performance and efficiency prediction
 bidirectional rings
 big and dumb processors
 bisection bandwidth
 block diagram
 block identification
 block placement
 block placement issues
 block replacement
 block servers vs filers
 block size and average memory access time
 blocking
 branch condition evaluation
 branch conditions
 branch correlation
 branch cost reduction
 branch hazard stalls
 branch hazards
 branch instructions
 branch issues
 branch penalty reduction
 branch prediction
 branch predictor
 branch predictor correlation
 branch predictors
 branch scheme performance
 branch schemes
 branch-prediction buffers
 branch-prediction schemes
 branch-target
 branch-target buffer
 branch-target buffer branch penalty
 branch-target buffers
 branches
 bubble sort
 bubble sort procedure
 buffer organizations
 bundles
 bus replacement
 bus-based coherent multiprocessor history
 bytes per reference vs block size
 cache access
 cache basics
 cache behavior calculations
 cache behavior impact
 cache block
 cache block placement
 cache blocks
 cache coherence
 cache coherence enforcement
 cache coherence example
 cache coherence extensions
 cache coherence mechanism
 cache coherence protocol
 cache coherency
 cache function
 cache hierarchy
 cache hit calculation
 cache hits
 cache miss
 cache miss calculations
 cache miss rates
 cache miss rates vs size
 cache misses
 cache optimization
 cache optimization basic categories
 cache optimization case study
 cache optimizations
 cache organization calculations
 cache organization impact
 cache performance
 cache performance average memory access time
 cache performance impact
 cache performance prediction
 cache protocols
 cache rule of thumb
 cache rule of thumb definition
 cache size and associativity
 cache size and misses per instruction
 cache size effect
 caches
 calculation
 call gates
 camera
 carry-lookahead adder
 carry-lookahead circuit
 carry-lookahead tree
 carry-lookahead tree adder
 carry-select adder
 carry-skip adder
 cartridge
 case studies
 case study
 case study example
 case study examples
 categories
 cell phone case study Nokia circuit board
 cell phones block diagram
 centralized shared-memory architectures
 centralized shared-memory multiprocessor structure
 centralized shared-memory multiprocessors
 centralized shared-memory multiprocessors basic considerations
 centralized switched networks
 chaining unchaining
 challenges
 characteristics
 chime approximation
 chip comparison
 chip fabrication case study
 chip fabrication cost
 chip fabrication cost case study
 chip layout
 class code sequence example
 classes
 classic pipeline stages
 classic stages for RISC
 classification
 clock rate
 clock rate trends
 clock rates
 clock rates bandwidth names
 cloud computing
 cloud computing costs
 cloud computing providers
 cluster history
 cluster server outage anomaly statistics
 clusters
 coarse-grained multithreading
 code size
 code size-compiler considerations
 coherence
 coherence enforcement
 coherence extensions
 coherence issues
 coherence maintenance
 coherence protocol
 coherency
 coining of term
 commercial congestion management
 commercial implementations
 commercial interconnection networks
 commercial routing arbitration switching
 commercial workload
 commercial workload implementation
 commercial workload measurement
 commercial workloads
 common case
 common exceptions
 common extensions
 communication bandwidth
 communication calculations
 communication latency
 communication mechanism
 communication performance
 communication protocols
 comparative operation measurements
 compare frequencies
 comparison
 comparisons
 compiler assumptions
 compiler history
 compiler optimization
 compiler optimization and performance
 compiler optimization impact
 compiler optimizations
 compiler performance
 compiler register allocation
 compiler scheduling
 compiler scheduling support
 compiler speculation support memory references
 compiler structure
 compiler support
 compiler techniques for exposure
 compiler technology and architectural decisions
 compiler technology and architecture decisions
 compiler types and classes
 compiler vectorization
 compiler writing-architecture relationship
 compiler-based speculation
 compiler-controlled prefetching
 compilers
 compilers see Compiler speculation concept origins
 complications
 component failure
 components
 compulsory miss rate
 computation-to-communication ratios
 compute bandwidth
 compute-optimized processors vs receiver overhead
 computer architecture
 computer architecture array switch
 computer architecture definition
 computer categories
 computer cluster forerunners
 computer components
 computer design innovations
 computer design principles
 computer history
 computer system availability
 computer system power consumption
 computer system power consumption case study
 computer systems
 computer trends
 computing history
 computing node
 concept
 condition codes
 conditional branch options
 conditional branches
 conditional branching
 conditional instructions
 conflict misses
 congestion management
 connectivity
 consistency model
 consistency models
 constant extension
 containers
 context
 continued instruction operator categories
 control dependence
 control dependences
 control flow instruction addressing modes
 control flow instruction branches
 control flow instructions
 control flow instructions addressing modes
 control hazards
 control instructions
 controller transitions
 conventions
 cooling and power
 cooling systems
 coprocessor relationship
 correlation
 cost
 cost calculations
 cost reduction
 cost trends
 cost vs access time
 cost vs price
 cost-performance
 cost-performance extensive pipelining
 costs
 credit-based control flow
 critical word first
 cross-company interoperability
 crossbar switch calculations
 crossbar switch interconnections
 cylinders
 data access benchmarks
 data access distribution
 data access distribution example
 data cache example
 data cache misses
 data caching
 data dependences
 data flow execution
 data flow limit
 data forwarding
 data hazard minimization
 data hazard stall minimization
 data hazard stalls
 data hazards
 data hazards requiring
 data hazards requiring stalls
 data on Internet
 data operands
 data reference sizes
 data transfer instructions
 data transfers
 data types
 data-intensive applications
 deadlock
 deconstruction case study
 defining
 definition
 definition and types
 definition terms
 definitions
 definitions and terms
 delay slot
 delayed
 delayed branch
 denormal multiplication
 denormals
 density- vs SPEC-optimized processors
 dependability
 dependability benchmarks
 dependability enhancement
 dependence analysis
 dependence computation elimination
 dependence distance
 dependences
 dependences locating
 dependent computation elimination
 dependent instructions
 description notation
 descriptor table
 descriptor tables as
 design
 desktop RISC instructions
 desktop RISCs
 desktop architectures
 desktop benchmarks
 desktop comptuers
 desktop computers
 desktop computing
 desktop multimedia support
 desktop performance
 desktop server
 desktop server RISCs
 desktop server systems
 desktop systems addressing modes
 detection and enhancement basic approach
 detection hardware
 detection logic
 deterministic vs adaptive routing
 development
 development of models
 development views
 device example
 die yield
 dies
 digital signal processors definition
 dimension-order routing
 direct network topology
 direct networks
 direct vs high-dimensional
 direct-mapped cache
 directory coherence
 directory controller
 directory protocol
 directory protocols
 directory-based
 directory-based cache coherence
 directory-based cache coherence DSM multiprocessor cache coherence
 directory-based cache coherence case study
 directory-based cache coherence protocol
 directory-based cache coherence protocol basics
 directory-based cache coherence protocol example
 directory-based cache coherence protocols
 directory-based coherence
 directory-based coherence case study
 directory-based see Directory-based cache coherence enforcement
 dirty bits
 disadvantages
 disk access scheduling
 disk array deconstruction
 disk array deconstruction case study
 disk arrays
 disk deconstruction
 disk deconstruction case study
 disk operators
 disk power
 disk seeks
 disk storage
 disk subsystem failure rates
 disks
 displacement addressing mode
 displacement values
 distributed shared-memory
 distributed switched networks
 distributed-memory
 distributed-memory multiprocessor
 distributed-memory multiprocessors
 distribution overview
 division radix-2 division
 domains
 double-precision FP operations
 during indexing
 during write
 dynamic
 dynamic branch prediction
 dynamic instruction mix
 dynamic scheduling
 dynamic scheduling basic concept
 dynamic scheduling with Tomasulo s algorithm
 dynamic voltage-frequency
 dynamically scheduled pipelines
 dynamically scheduling with scoreboard
 early IBM computers
 early IBM work
 early LANs and W ANs Ethernet switches
 early VM work
 early computer arithmetic
 early computers
 early development
 early machines
 early performance measures
 early pipelined CPUs
 early pipelined versions
 early schemes
 early studies
 early work
 effective address cycle
 effective bandwidth
 effective bandwidth calculations
 effective bandwidth vs nodes
 effective bandwidth vs packet size
 effectiveness
 efficiency measurement
 embedded DSP extensions
 embedded RISC data transfers
 embedded RISC extensions
 embedded RISCs
 embedded applications basic considerations
 embedded architectures
 embedded benchmarks
 embedded computers
 embedded instruction format
 embedded multiprocessors
 embedded system case study characteristics
 embedded systems
 empowerTel Networks MXP processor
 enabling technologies
 encoding
 encoding considerations
 energy and power
 energy consumption
 energy efficiency
 energy performance fallacies
 energy savings
 enhanced DAXPY performance
 enhancements
 equivalent RISC instructions arithmetic logical
 erasure encoding
 errors and faults
 evaluation
 even odd array
 evolution
 exampl
 example
 example and algorithms
 example calculation
 example calculations
 example code
 example system
 examples
 examples and characteristics
 exception stopping restarting
 exception types
 exception types and requirements
 exceptions
 execution
 execution effective address cycle
 execution sequences
 execution time
 execution times
 explicit parallelism
 exploitation methods
 exploitation statically
 exponential back-off
 exposing with hardware support
 extensions
 extensive pipelining
 facility capital costs
 factors in improvement
 failures
 fallacies
 false sharing
 fast address translation
 fast traps
 fat trees
 fault detection
 fault detection pitfalls
 fault tolerance
 fault tolerance calculations
 faults
 features
 fetch-and-increment
 fetch-and-increment barrier
 field
 fields
 file system benchmarking
 finding
 fine-grained
 fine-grained multithreading
 fine-grained multithreading on Sun T1
 fine-grained on T1
 first dynamic scheduling
 first vector computers
 first-level caches
 fixed-point arithmetic
 flawed architectures
 flawless architecture design
 flawless design
 flaws and success
 flaws vs success
 floating point denormals
 floating point exceptions
 floating point remainder
 floating-point
 floating-point addition
 floating-point addition denormals
 floating-point addition rules
 floating-point addition speedup
 floating-point additions
 floating-point arithmetic
 floating-point calculations
 floating-point exceptions
 floating-point iterative
 floating-point multiplication denormals
 floating-point operations
 floating-point pipeline
 floating-point precisions
 floating-point square root
 floating-point stall
 floating-point standard
 floating-point underflow
 floorplan
 for exposing parallelism
 for parallel programming
 for performance gains
 for speedup
 format
 format example
 forwarding
 from ILP
 from RAW hazards FP code
 full
 full procedure
 function
 functional hazards
 functional units
 functions
 fused multiply-add
 future GPU features
 future architectures
 future features
 gather scatter operations
 gather-scatter
 general-purpose register computers
 geometric means
 geometric means calculations
 global code scheduling
 goals functions requirements
 gradual
 graph coloring
 graphics memory
 graphics pipeline history
 half
 hardward fallacies
 hardware ILP model
 hardware dependability
 hardware description notation
 hardware impact on software development
 hardware instruction prefetching
 hardware prefetching
 hardware primitives
 hardware support
 hardware vs software
 hardware vs software speculation
 hardware-based execution
 hardware-based speculation
 hazard checks
 hazard classes
 hazard detection
 hazards
 hazards and forwarding
 hazards stalls
 headers
 heterogeneous
 hiding with speculation
 hierarchy
 high memory bandwidth
 high-level considerations
 high-level instruction set
 high-level language
 high-level language computer architecture
 high-performance computing
 highly parallel memory systems
 historical background
 historical milestones
 historical overview
 historical performance milestones
 historical trends
 history
 hit time power reduction
 hit time reduction
 ideal processor
 ideal processors
 immediate addressing mode
 immediate operands
 immediate value distribution
 implementation
 implementation difficulties
 imprecise
 improvement over time
 in MIPS R4000
 in parallel
 in registers
 in vector architectures
 inclusion
 independent
 independent FP operations
 index checks
 information tables
 input-output-buffered switch
 inside disks
 instruciton set encoding
 instruction classes
 instruction decode
 instruction delivery and speculation
 instruction encoding
 instruction execution
 instruction execution example
 instruction execution frequencies
 instruction execution issues
 instruction fetch
 instruction fetch bandwidth
 instruction fetch bandwidth basic considerations
 instruction format
 instruction formats
 instruction formats core instructions
 instruction handling
 instruction latency
 instruction lengths
 instruction list
 instruction miss benchmarks
 instruction misses
 instruction mix
 instruction operator categories
 instruction operators
 instruction packet
 instruction scheduling
 instruction set
 instruction set architecture formats
 instruction set basics
 instruction set complications
 instruction set encoding
 instruction set lineage
 instruction set operations
 instruction set principles
 instruction set usage measurements
 instruction sets
 instruction simulation
 instruction steps
 instruction subset
 instruction types
 instruction-level parallelism
 instructions
 instructions and functions
 instructions and hazards
 instructions vs DLX
 integer FP R-R operations
 integer SRT division
 integer addition carry-lookahead
 integer addition speedup
 integer addition speedup carry-lookahead
 integer arithmetic
 integer arithmetic array multiplier
 integer arithmetic language comparison
 integer conversions
 integer division
 integer division radix-2 division
 integer division remainder
 integer division speedup
 integer multiplication
 integer multiplication array multiplier
 integer multiplication division shifting over zeros
 integer multiplication speedup even odd array
 integer operations
 integer overflow
 integer pipeline
 integer shifting over zeros
 integer speedup carry-lookahead
 integer vs FP programs
 integer-FP conversions
 integers
 integers speedup radix-2 division
 integers with adder
 integrated circuit cost
 integrated circuit cost trends
 integrated circuit costs
 integrated circuit failure
 integrated circuit improvements
 integrated circuits
 integrated instruction fetch units
 integrated units
 intelligent interfaces
 interconnected networks
 interconnecting node calculations
 interconnecting node costs
 interconnection network
 interconnection network characteristics
 interconnection network domain relationship
 interconnection network domains
 interconnection network latency and effective bandwidth
 interconnection network protection
 interconnection network speed
 interconnection network topology
 interconnection networks
 interconnection networks bandwidth considerations
 interconnection networks multi-device networks
 interface functions
 interlane wiring
 interleaved cache banks
 internal microprocessors
 internal organization
 internetworking
 interpretation
 interprocessor communication
 invalidate protocol
 invalidate protocol implementation
 invalidate protocols
 invalidation protocol
 invocation options
 issues
 issues with
 iterative division
 jump prediction
 jumps procedure calls
 k-ary n-cubes definition
 kernel characteristics
 kernel suites
 key ideas
 lack in shared-memory ARM Cortex-A8
 lane considerations
 lane recognition
 language comparison
 large-scale multiprocessor cache coherence
 large-scale multiprocessor history
 large-scale multiprocessor locks
 large-scale multiprocessor synchronization
 large-scale multiprocessor synchronization barrier synchronization
 large-scale multiprocessor trends
 large-scale multiprocessors
 large-scale multiprocessors advantages
 large-scale multiprocessors barrier synchronization
 large-scale multiprocessors deadlock and buffering
 large-scale multiprocessors scientific applications distributed-memory multiprocessors
 latencies
 latency
 latency and effective bandwidth
 latency effects
 latency hiding
 latency hiding in consistency models
 latency hiding with speculation
 latency in consistency models
 latency issues
 latency vs nodes
 layer
 layer definitions
 levels in slow down
 limit
 limitation studies
 limitations
 linear
 linear speedups
 link bandwidth
 literal addressing mode
 load instruction
 load interlocks
 load-store
 load-store instructions
 local global predictor combinations
 locality principle
 locating dependences
 lock accesses
 lock implementation
 locks via coherence
 logic technology
 logical units
 long latency pipelines
 longer latency pipelines
 loop interchange
 loop iteration example
 loop unrolling
 loop unrolling scheduling
 loop-based example
 loop-carried dependences
 loop-level parallelism
 loop-level parallelism calculations
 loop-level parallelism dependences
 loops execution pattern
 lossless vs lossy networks
 low-dimensional topologies
 low-to-high-end roles
 magnetic storage
 magnetic storage history
 mail server benchmarking
 main memory
 main memory block
 mainstream computing classes
 maintaining
 manufacturing
 manufacturing cost
 manufacturing vs operation
 many adders
 mapping example
 mapping examples
 mapping to physical
 mask registers
 measurement
 measurement reporting summarization
 measurements
 measures
 mechanical design
 mechanism
 media extensions
 memory
 memory access cycle shift
 memory access penalty
 memory access times
 memory accesses
 memory address interpretation
 memory addressing
 memory and vector performance
 memory bandwidth
 memory banks
 memory basics
 memory block
 memory consistency
 memory consistency models
 memory consistency models basic considerations
 memory dependability
 memory hierarchy
 memory hierarchy and OS
 memory hierarchy basics
 memory hierarchy design
 memory hierarchy development
 memory hierarchy example
 memory hierarchy history
 memory hierarchy interface
 memory in cache
 memory mapping
 memory performance
 memory port conflict
 memory protection
 memory protection performance
 memory reference hardware support
 memory stall clock cycles
 memory system coherency
 memory systems
 memory threads GPUs
 mesh network
 mesh network routing
 message composition processing
 message copying issues
 message-passing communication
 metrics
 microarchitectural techniques
 microarchitectural techniques case study
 microarchitecture
 microcontroller cell phones
 microprocessor
 microprocessor advances
 microprocessor developments
 microprocessor die example
 microprocessor dynamic energy power
 microprocessors
 misaligned addresses
 misprediction rate
 misprediction rates
 misprediction rates on SPEC89
 miss categories
 miss penalties
 miss penalty
 miss penalty calculations
 miss penalty rate reduction
 miss penalty reduction
 miss penalty reduction via multilevel caches
 miss rate
 miss rate benchmarks
 miss rate calculation
 miss rate calculations
 miss rate reduction
 miss rate reduction via associativity
 miss rate vs cache size
 miss rate vs virtual addressing
 miss rates
 miss rates and cache sizes
 miss statistics
 miss support
 misses
 misses per instruction
 misses single vs multiple thread executions
 misspeculation
 misspeculation instructions
 mobile client server features
 mobile vs server GPUs
 model
 model RAID performance prediction
 model example
 modeling
 modern processors
 modules
 modules SLAs
 monitoring and repairing
 multi-device connections basic considerations
 multi-device interconnection networks
 multi-device interconnections shared- vs switched-media networks
 multi-device networks
 multibanked caches
 multichip cache and memory states
 multichip multicore multiprocessor
 multicore performance energy efficiency
 multicore processor performance
 multicore processor performance real-world server considerations
 multicore processors
 multicore processors and SMT
 multicore single-chip multiprocessor
 multicore vs single-core
 multicycle operations basic considerations
 multidimensional arrays
 multidimensional arrays in vector architectures
 multilevel application
 multilevel caches
 multilevel exclusion
 multilevel inclusion
 multimedia architecture programming
 multimedia compiler support
 multimedia extensions
 multimedia extensions see Multimedia SIMD Extensions multiprocessor architecture
 multimedia instruction compiler support
 multimedia instruction compilers
 multimedia instruction support
 multimedia instructions
 multimedia support
 multipass array multiplier
 multipass system
 multiple branch speculation
 multiple branches
 multiple device connections
 multiple issue processor
 multiple issue processor approaches
 multiple issue speculation overcoming data hazards
 multiple issue static scheduling
 multiple lane vector unit
 multiple lanes
 multiple outstanding
 multiple outstanding FP operations
 multiple-issue processor
 multiple-issue processor development
 multiple-issue processor history
 multiple-issue processors
 multiplication
 multiplication algorithm
 multiplication array multiplier
 multiplication division shifting over zeros
 multiplication examples
 multiplication precision
 multiply-accumulate
 multiprocessing
 multiprocessing multithreading
 multiprocessing multithreading-based performance
 multiprocessor
 multiprocessor architecture
 multiprocessor cache coherence
 multiprocessor cache coherency
 multiprocessor communication calculations
 multiprocessor cost effectiveness
 multiprocessor cost relationship
 multiprocessor importance
 multiprocessor linear speedup
 multiprocessor performance
 multiprocessor scaled programs
 multiprocessor software development
 multiprocessor-optimized software
 multiprocessors
 multiprocessors measurement issues
 multiprogrammed parallel make workload
 multiprogrammed workload
 multiprogramming
 multiprogramming and OS workload
 multiprogramming workload
 multiprogramming workloads
 multithreaded SIMD Processor
 multithreaded SIMD Processor block diagram
 multithreaded processor
 multithreaded see Multithreaded SIMD Processor NVIDIA GPU computational structures
 multithreading
 multithreading approaches
 multithreading basic considerations
 multithreading benchmarks
 multithreading history
 multithreading support
 multithreading-based speedup
 n-bit adder carry-lookahead
 n-bit number representation
 n-bit unsigned integer division
 n-bit unsigned integers
 name dependences
 natural
 necessity
 network WSC memory hierarchy
 network array and Internet linkage
 network as bottleneck
 network effective bandwidth
 network example
 network fault tolerance
 network impact
 network interface
 network interface functions
 network interfaces
 network linkage
 network performance and cost
 network performance and topology
 network performance effects
 network routing
 network topologies
 network topology
 network topology performance and costs
 network user access
 network-only features
 networks
 nonaligned data transfers
 nonblocking cache
 nonblocking caches
 nonvirtualizable ISA
 nullifying
 number representation
 observed
 ocean application
 offload engines
 on VMIPS
 on enhanced VMIPS
 opcode
 open-source software
 operand
 operand addressing mode
 operand forwarding
 operand locations
 operand sizes types
 operand specifiers
 operand type and size
 operand type distribution
 operand types and sizes
 operand types sizes
 operand usage
 operands
 operands per ALU
 operands per ALU instruction
 operands per instruction example
 operation count
 operations
 operator categories
 operator dependability
 operators
 optimization
 optimization types
 organizations
 out-of-order completion
 out-of-order example
 out-of-order execution
 out-of-order processors
 outage anomaly statistics
 overcoming data hazards
 overflow
 overlapped integer FP operations
 overview
 p bits
 packet blocking
 packet format
 packet latency
 packets
 page level write-through
 page size changes
 page size selection
 page table-based mapping
 page tables
 paged example
 paged virtual memory
 paged virtual memory example
 paging
 paging vs segmentation
 parallel
 parallel benchmarks
 parallel processing
 parallel processing calculations
 parallel processing challenges
 parallel processing debates
 parallel processors
 parallel program computation communication
 parallel programming
 parallel vs sequential programs
 parallelism
 parallelism advantages
 parallelism and parallel architectures
 parallelism classes
 parallelism exploitation statically
 parallelism measurement
 parallelism vs window size
 parameter ranges
 partitioning
 passes
 peak DLP
 peak performance
 peak performance focus
 peak performance on DAXPY
 peak performance vs start-up overhead
 penalty reduction
 per ALU instruction example
 per reference vs block size
 perfect processor
 performance
 performance and costs
 performance and efficiency prediction
 performance and energy efficiency
 performance bandwidth trade-offs
 performance benchmarks
 performance characterization
 performance commercial workload
 performance comparison
 performance considerations
 performance dependability cost
 performance effects
 performance energy efficiency
 performance enhancement chaining
 performance equations
 performance gains
 performance histories
 performance impact
 performance impact calculations
 performance issues
 performance measurement
 performance measurement history
 performance milestones
 performance on Linpack
 performance prediction
 performance price power considerations
 performance reporting
 performance results reporting
 performance scaling
 performance trends
 performance vs productivity
 performance with stalls
 personal computers
 phone block diagram
 phone characteristics
 physical infrastructure and costs
 pipe stage
 pipe stages
 pipeline
 pipeline branch issues
 pipeline branch penalties
 pipeline branches
 pipeline control
 pipeline depths
 pipeline execution rate
 pipeline hazard detection
 pipeline issues
 pipeline overview
 pipeline performance
 pipeline scheduling
 pipeline scheduling loop unrolling
 pipeline stall
 pipeline stalls
 pipeline structural hazards
 pipeline structure
 pipeline timing
 pipeline with stalls
 pipelined cache access
 pipelined version
 pipelines
 pipelines with stalls
 pipeling performance issues
 pipelining
 pipelining basics
 pipelining concept
 pipelining efficiency
 pipelining example
 pipelining exceptions
 pipelining performance
 pipelining performance issues
 pitfalls
 pjbb2005 benchmark Intel Core i7
 placement in main memory
 point-to-point example
 point-to-point links
 point-to-point links and switches
 point-to-point replacement
 points-to analysis
 popularity
 power
 power DLP issues
 power and energy
 power and energy system trends
 power calculations
 power consumption
 power consumption and efficiency
 power consumption and efficiency metrics
 power distribution example
 power failure
 power modes
 power utilities
 power-performance
 power-performance benchmarks
 power-performance modes
 precise
 precise exceptions
 precision
 precisions
 predicated instructions
 predication and speculation
 predicted-not-taken scheme
 prediction
 prediction accuracy
 prediction buffer
 prediction buffers
 predictor misprediction rates
 predictors on SPEC89
 prefetch
 prefetch units
 preservation via hardward support
 preserving exception behavior
 price and characteristics
 price performance power considerations
 primary approaches
 primitives
 principle of locality
 private cache
 procedure invocation options
 process protection
 process switch
 processes
 processor benchmarks
 processor clock rate
 processor clock rates
 processor comparison
 processor comparisons
 processor example
 processor examples
 processor history
 processor instruction latency
 processor performance calculations
 processor performance comparison
 processor performance equation
 processor performance time
 processor performance trends
 processor trends
 processors big and dumb processors
 processors historical growth
 producer-server model
 profile-based predictor
 programmer s viewpoint
 programming
 programming mistakes
 programming models and workloads
 programming viewpoint
 protecting processes
 protection
 protection and ISA
 protection process
 protection schemes
 protocol basics
 protocol definitions
 protocol example
 protocol stack
 protocol-level communication
 provider issues
 purpose
 quantitative measures
 queing theory
 query response-time curve
 queue I O request calculations
 queue I O requests
 queue calculations
 queue waiting time
 queuing
 queuing theory
 radio receiver
 radix-2 division
 radix-4
 radix-4 SRT division
 radix-4 division
 random distribution
 random variable distribution
 random variables
 rate calculations
 raw relative GPU performance
 raw relative performance
 read misses
 read misses vs writes
 real faults and failures
 real-time PMDs
 real-time processing
 real-world considerations
 real-world examples
 real-world server considerations
 realizable processor ILP
 realizable processor limitations
 reboot instruction execution issues
 reboots
 recent advances
 recent advances and developments
 reconstruction case study
 recurrence form
 recurrences
 reduction
 reduction via multilevel caches
 reductions
 redundant power supplies
 redundant power supply reliability
 register additions
 register allocation
 register model
 register preservation
 register renaming code
 register renaming vs ROB
 register windows
 registers
 registers and usage conventions
 relative
 relaxed consistency
 relaxed consistency models
 reliability
 reliance on
 remainder
 rename table and register substitution logic
 reorder buffer
 replacement by RISC
 representation
 request-level
 requirements
 requirements and implementation
 reservation stations register tags
 resource allocation
 response time restrictions
 response time restrictions for benchmarks
 restoring nonrestoring
 restoring nonrestoring division
 results reporting
 results summarization
 results tables
 return address buffer
 return address predictors
 ring network
 rings
 ripple-carry
 ripple-carry adder
 ripply-carry addition
 role
 roofline visual performance model
 rounding
 rounding modes
 routers gateways
 routing
 routing algorithms
 routing arbitration switching impact
 routing comparison
 routing example
 row-diagonal parity
 rules
 safe calls
 sample calculations
 sample code
 sample program
 sample renaming code
 sample results
 sample types
 saturating operations
 scalable
 scalable GPUs
 scalar performance
 scaled
 scaling
 scheduling
 scheduling example
 scheme performance
 scientific application performance
 scientific application performance distributed-memory multiprocessors
 scientific applications
 scientific applications on parallel processing
 scientific applications on parallel processors
 scientific workloads
 scientific workloads distributed-memory multiprocessors
 scientific workloads on symmetric shared-memory multiprocessors
 scoreboard components
 scoreboarding
 scoreboarding definition
 scoreboarding steps
 second-level cache size
 see Intellectual Property IP cores Internet Protocol IP IPC see Instructions per clock IPC IPoIB
 seek distance comparison
 seek time vs distance
 segment descriptors
 segmented example
 segmented scheme
 segmented virtual memory
 segmented virtual memory example
 selection
 self-routing
 sense-reversing barrier
 sequential consistency
 server
 server CPUs
 server benchmarks
 server calculations
 server costs
 server energy efficiency
 server energy savings
 server performance
 server power
 server power-performance benchmarks
 server usage
 server utilization calculation
 server vs PMD
 servers
 shared- vs switched-media networks
 shared-media networks
 shared-memory communication
 shared-memory multiprocessor
 shared-memory multiprocessor workload
 shared-memory multiprocessors
 shared-memory multiprogramming workload
 shared-memory see Shared-memory multiprocessors SMP
 shared-memory workload
 shared-memory workload performance
 shared-memory workloads
 sharing and protection
 sharing protection
 shrinking
 signed numbers
 signed-digit addition table
 signed-digit numbers
 simple MIPS implementation
 simple RISC
 simple RISC implementation
 simple first-level caches
 simple implementation
 simple pipeline
 simple scheme examples
 simultaneous on superscalars
 single adder
 single memory location example
 single vs multiple thread executions
 single-chip case study
 single-chip multicore case study
 single-chip multicore multiprocessor
 single-chip multicore multiprocessor case study
 single-chip multicore processor
 single-chip multicore processor case study
 single-precision numbers
 single-server model
 single-thread
 single-threaded benchmarks
 size equations
 size selection
 sizes and associativities
 slowdown causes
 snooping
 snooping cache
 snooping cache coherence
 snooping cache coherence implementation
 snooping coherence
 snooping coherence implementation
 snooping coherence implementation Index
 snooping coherence protocol
 snooping coherence protocols
 snooping coherence snooping coherence protocols
 snooping limitations
 snooping protocols
 snooping see Snooping cache coherence state diagram
 software development
 software implementations
 software importance
 software optimization
 software overhead
 software overhead issues
 software pipelining
 sort
 sort code
 sort register allocation
 sorting
 sorting case study
 source operands
 space and relation of classes
 sparse matrices
 special values
 special values and denormals
 speculation
 speculation advantages MIPS64-unique
 speculation advantages disadvantages
 speculation and energy efficiency
 speculation concept origins
 speculation cost
 speculation support
 speculation through multiple branches
 speculation to hide latency
 speculative execution
 speed considerations
 speed trends
 speedup
 speedup benchmarks
 speedup via parallelism
 speedup without SMT
 spin lock
 splitting from main memory
 ssj ops see Server side Java operations per second ssj ops SSP see Single-Streaming Processor SSP Stack architecture and compiler technology
 stack
 stack architectures
 stages TI 320C55 DSP
 stall as
 stall reduction
 stall requirements
 stalls
 stalls from RAW hazards
 standards and evolution
 start-up and multiple lanes
 start-up latency and dead time
 start-up overhead
 start-up penalties
 state transition diagram
 static
 static branch prediction
 static power
 statistics examples
 status table examples
 status tables
 step details
 steps and bus traffic examples
 stopping restarting
 stopping restarting execution
 storage
 storage area network history
 storage area networks
 storage system benchmarks
 storage system components
 storage systems
 streaming Multiprocessor
 stride
 stride handling
 strided access interactions
 strided access-TLB interactions
 strides
 strip mining
 strip-mined loop
 strip-mining
 structural hazard
 structural hazards
 structure
 structure and functions
 studies
 study
 superblock scheduling
 supercomputer development
 superlinear
 superscalar SMT
 superscalar code
 superscalar processors
 swap
 swap and register preservation
 swap code
 swap full procedure
 switch buffer organizations
 switch hierarchy
 switch microarchitecture
 switch microarchitecture pipelining
 switch size
 switch to DLP TLP RLP
 switch vs NIC
 switched network topologies
 switched network topology
 switched networks
 switched-media networks
 switches
 switches see Switch microarchitecture techniques case study
 switching
 symmetric shared-memory machines
 symmetric shared-memory multiprocessor
 symmetric shared-memory multiprocessor performance
 symmetric shared-memory multiprocessor performance commercial workload
 symmetric shared-memory multiprocessors
 synchronization
 synchronization and consistency models
 synchronization basic considerations
 synchronization history
 synchronization marker
 synchronization mechanisms
 synchronization performance
 system
 system area network history
 system area networks
 system call performance
 system call virtualization paravirtualization
 system call virtualization paravirtualization performance
 system characteristics
 system comparison
 system evolution
 system log
 system storage area network
 system trends
 systems issues
 tailgating
 task-level
 technique
 techniques overview
 technology trends
 terminology
 terminology comparison
 thread count and memory performance
 thread scheduling
 three-level cache hierarchy
 throughput computing kernel
 throughput vs command queue depth
 throughput vs response time
 tier classifications
 time of flight
 time space requirements
 time volume commoditization
 time volume commoditization impact
 to
 to F5
 to J43
 to J43 example
 to RAID row-diagonal parity
 to ROB commit
 to pipeline structural precisions
 to pipeline structure
 to remainder
 top 80x86 instructions
 top instructions
 top-level architecture
 topology
 topology routing arbitration switching
 torus topology interconnections
 total time statistics
 tournament predictors
 trace scheduling
 transactions components
 transistor performance and wires
 transistor scaling
 transistors scaling
 translation
 tree
 tree-based barriers
 trends
 true
 true sharing misses and false sharing
 two-bit predictor comparison
 two-bit predictors
 two-device interconnections basic considerations
 two-device networks
 type and size
 types
 types and classes
 types and requirements
 typical operations
 typical program fallacy
 typical programs
 unaligned word read instructions
 uncached state
 underflow
 unfinished instructions
 unified
 uniform memory access
 uniprocessors
 uniprocessors TLP basic considerations
 unique instructions
 unoptimized code
 unpipelined functional units
 usage
 user experience
 user-to-OS gates
 utilities
 utility computing
 utility computing history
 utilization calculations
 value distribution
 value distributions
 value prediction
 variable encoding
 vector
 vector GPU comparison
 vector add instruction
 vector and memory bandwidth
 vector architecture
 vector architecture basic considerations
 vector architecture programming
 vector architectures
 vector architectures as superset
 vector chaining
 vector compilers
 vector convoys
 vector execution time
 vector instruction set
 vector kernel implementation
 vector kernel on vector processor and GPU
 vector length
 vector load store unit bandwidth
 vector load store units
 vector load-store unit bandwidth
 vector mask registers
 vector memory systems
 vector multiple lanes
 vector on vector processor and GPU
 vector operations
 vector performance
 vector performance and memory bandwidth
 vector performance calculations
 vector performance measures
 vector processor
 vector processor example
 vector processor history
 vector processor performance
 vector processors
 vector processors chaining
 vector registers
 vector sequence calculations
 vector sequence chimes
 vector sparse matrices
 vector start-up
 vector starting times
 vector systems
 vector unit structure
 vector units
 vector vs GPU
 vector vs scalar
 vector vs scalar operation
 vector vs scalar performance
 vector-GPU comparison
 vector-length registers
 vector-mask registers
 vector-register characteristics
 vectorization
 vectorization in code
 vectors vs GPUs
 via block size
 via cache size
 via computing
 via miss rates
 via parallelism
 virtual
 virtual channels and throughput
 virtual functions methods
 virtual machine monitor
 virtual memory
 virtual memory and programming
 virtual memory basic considerations
 virtual memory block identification
 virtual memory block replacement
 virtual memory definition
 virtual memory fast address translation
 virtual memory history
 virtual memory miss
 virtual memory page size selection
 virtual memory protection
 virtual memory writes
 virtual memory-based protection
 virtual to cache access scenario
 virtual-to-physical address mapping
 virtualization issues
 virtualization paravirtualization performance
 virtually addressed
 vs Flash memory
 vs GPUs
 vs Google WSC
 vs Grid
 vs I O subsystem
 vs Intel 80x86 operations
 vs MIMD with Multimedia SIMD
 vs MIN costs
 vs MIPS
 vs MIPS M2000
 vs MIPS code
 vs MIPS32
 vs MIPS32 sort
 vs Multimedia SIMD Extensions
 vs NIC
 vs Opteron memory protection
 vs POSIX Threads
 vs PTX
 vs Pentium protection
 vs RISC
 vs ROB
 vs SAS drives
 vs SATA drives
 vs SIMD
 vs SIMD Processor
 vs TCP IP reliance
 vs VAX
 vs WSC costs
 vs WSC facility costs
 vs WSCs
 vs bandwidth
 vs block size
 vs buses
 vs bytes per reference
 vs cache performance
 vs caches
 vs deterministic routing
 vs direct network costs
 vs direct networks
 vs dynamic scheduling
 vs hardware speculation
 vs high-dimensional networks
 vs interconnected nodes
 vs latency
 vs miss rate
 vs mobile GPUs
 vs multithreading
 vs name dependence
 vs network-only features
 vs operation cost
 vs packet size
 vs page
 vs paged
 vs parallelism
 vs peak performance
 vs price
 vs processor performance equation
 vs register renaming
 vs response time
 vs scalar performance
 vs scalar processor
 vs segmented
 vs segments
 vs server GPUs
 vs servers
 vs shared-media networks
 vs software speculation
 vs static power
 vs switched networks
 vs switched-media networks
 vs switches
 vs throughput
 vs vector
 vs vector architectures
 vs vector performance
 vs vector processor operation
 vs virtual addressed cache size
 vs virtual memory
 vs window size
 vs write-through
 wafer example
 waiting time calculations
 warehouse-scale computers
 way prediction
 way selection
 weaknesses
 web server benchmarking
 wireless communication challenges
 wireless network overview
 wireless networks
 with DSM
 with Multimedia SIMD vs GPU
 with dynamic scheduling and multiple issue
 with dynamic scheduling and speculation
 with large-scale multiprocessors
 with many adders
 with multiple issue and speculation
 with ripple-carry adder
 with scoreboard
 with single adder
 with speculation
 without SMT
 workload demands
 workload execution time
 wormhole switching
 wormhole switching performance
 write buffer
 write buffer and read misses
 write buffer merging
 write invalid protocol
 write invalidate protocol implementation
 write merging example
 write process
 write speed calculations
 write strategy
 write vs no-write allocate
 write-back
 write-back cache
 writes
 x
 x vs
 x86
 yield
 zero-copy protocols
